# Azure DevOps Pipeline - Frontend (Next.js) to Azure Web App Linux
# Deploys custom-forms/runtime-app to Azure Web App: bizuit-custom-forms

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - custom-forms/runtime-app/**

variables:
  nodeVersion: '22.x'
  azureSubscription: 'Azure BIZUIT'  # Service Connection name
  webAppName: 'bizuit-custom-forms'
  resourceGroup: 'BIZUIT'

  # Backend API URL (FastAPI)
  backendApiUrl: 'https://bizuit-custom-forms-api-c0c3c9fbb8adafbh.eastus-01.azurewebsites.net'

  # Runtime basePath for deployment
  runtimeBasePath: ''  # Empty = root path (no virtual directory)

  # Standalone Forms (Iframe) Configuration
  allowedIframeOrigins: 'https://test.bizuit.com,https://*.bizuit.com'  # Comma-separated, supports wildcards
  allowLocalhostIframe: 'false'  # true for dev, false for production

stages:
  # ==========================================================================
  # STAGE 1: Build Next.js Application
  # ==========================================================================
  - stage: Build
    displayName: 'Build Next.js Application'
    pool:
      vmImage: 'ubuntu-latest'  # Linux agent for faster builds
    jobs:
      - job: BuildJob
        displayName: 'Build Runtime App'
        steps:
          - checkout: self
            clean: true
            displayName: 'Checkout Repository'

          - task: NodeTool@0
            inputs:
              versionSpec: '$(nodeVersion)'
            displayName: 'Install Node.js $(nodeVersion)'

          # Cache npm dependencies for faster builds
          - task: Cache@2
            inputs:
              key: 'npm-v2 | "$(Agent.OS)" | custom-forms/runtime-app/package-lock.json'
              restoreKeys: |
                npm-v2 | "$(Agent.OS)"
                npm-v2
              path: '$(Build.SourcesDirectory)/custom-forms/runtime-app/node_modules'
            displayName: 'Cache npm dependencies'

          # Cache Next.js build for faster rebuilds
          - task: Cache@2
            inputs:
              key: 'nextjs-v2 | "$(Agent.OS)" | custom-forms/runtime-app/package-lock.json'
              restoreKeys: |
                nextjs-v2 | "$(Agent.OS)"
                nextjs-v2
              path: '$(Build.SourcesDirectory)/custom-forms/runtime-app/.next/cache'
            displayName: 'Cache Next.js build'
            continueOnError: true

          # Install runtime app dependencies (npm ci fetches published packages from registry)
          - script: |
              cd custom-forms/runtime-app
              npm ci
            displayName: 'Install Runtime App Dependencies'

          # Create .env.local for build (build-time variables)
          - task: Bash@3
            inputs:
              targetType: 'inline'
              workingDirectory: 'custom-forms/runtime-app'
              script: |
                echo "Creating .env.local for build..."
                cat > .env.local <<'EOF'
                # Build-time Environment Variables
                # These are baked into the Next.js build

                # Base path for Azure Web App deployment
                NEXT_PUBLIC_BASE_PATH=$(runtimeBasePath)

                # Bizuit BPM Dashboard API URL (browser connects to BPM)
                NEXT_PUBLIC_BIZUIT_DASHBOARD_API_URL=https://test.bizuit.com/arielschbizuitdashboardapi/api

                # Custom Forms Backend API URL (browser connects to FastAPI backend)
                NEXT_PUBLIC_BIZUIT_FORMS_API_URL=$(backendApiUrl)

                # Timeouts and configuration
                NEXT_PUBLIC_BIZUIT_TIMEOUT=30000
                NEXT_PUBLIC_BIZUIT_TOKEN_EXPIRATION_MINUTES=1440

                # Session timeout
                NEXT_PUBLIC_SESSION_TIMEOUT_MINUTES=30

                # ðŸ”’ Standalone Forms (Iframe) Configuration
                # Allowed origins for iframe embedding (/formsa/* routes)
                # Comma-separated list of domains, supports wildcards: https://*.bizuit.com
                NEXT_PUBLIC_ALLOWED_IFRAME_ORIGINS=$(allowedIframeOrigins)

                # Allow localhost for iframe testing (ONLY for development, false in production)
                NEXT_PUBLIC_ALLOW_LOCALHOST_IFRAME=$(allowLocalhostIframe)

                # Server-side Environment Variables (not baked into build)
                # FASTAPI_URL is used by Next.js API routes (server-side only)
                FASTAPI_URL=$(backendApiUrl)

                # ðŸ”’ Form Security - Server-side only (configurable at runtime)
                # Set to 'false' for production (requires Dashboard token)
                ALLOW_DEV_MODE=false

                # Environment
                NODE_ENV=production
                EOF

                echo "âœ“ .env.local created"
                cat .env.local
            displayName: 'Create Build Environment Configuration'

          # Build Next.js with standalone output
          - task: Npm@1
            inputs:
              command: 'custom'
              customCommand: 'run build'
              workingDir: 'custom-forms/runtime-app'
            displayName: 'Build Next.js Application'
            env:
              NEXT_PUBLIC_BASE_PATH: '$(runtimeBasePath)'
              NODE_ENV: 'production'

          # Copy build files (exclude node_modules - standalone includes only necessary deps)
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)/custom-forms/runtime-app'
              Contents: |
                .next/standalone/**
                .next/static/**
                .next/server/**
                .next/BUILD_ID
                .next/*.json
                public/**
                scripts/prepare-deployment.js
                !node_modules/**
                !.next/cache/**
                !package.json
              TargetFolder: '$(Build.ArtifactStagingDirectory)/runtime-app-temp'
            displayName: 'Copy Runtime Build Files'

          # Prepare standalone deployment (standard Next.js pattern)
          - task: Bash@3
            inputs:
              targetType: 'inline'
              script: |
                echo "=== Preparing Next.js Standalone Deployment ==="

                TEMP_DIR="$(Build.ArtifactStagingDirectory)/runtime-app-temp"
                DEPLOY_DIR="$(Build.ArtifactStagingDirectory)/runtime-app"

                # Verify standalone build exists
                if [ ! -d "$TEMP_DIR/.next/standalone" ]; then
                  echo "âŒ ERROR: Standalone build not found"
                  ls -la $TEMP_DIR/.next/
                  exit 1
                fi

                # Copy standalone build to deployment directory
                echo "Copying standalone build..."
                mkdir -p $DEPLOY_DIR
                cp -r $TEMP_DIR/.next/standalone/* $DEPLOY_DIR/

                # Move static assets into standalone structure (standard Next.js pattern)
                echo "Moving static assets..."
                if [ -d "$TEMP_DIR/.next/static" ]; then
                  mkdir -p $DEPLOY_DIR/.next/static
                  cp -r $TEMP_DIR/.next/static/* $DEPLOY_DIR/.next/static/
                  echo "âœ“ Static assets moved"
                fi

                # Copy required Next.js manifest files (not in standalone/)
                echo "Copying Next.js manifests and BUILD_ID..."
                mkdir -p $DEPLOY_DIR/.next

                # Copy BUILD_ID if exists
                if [ -f "$TEMP_DIR/.next/BUILD_ID" ]; then
                  cp "$TEMP_DIR/.next/BUILD_ID" "$DEPLOY_DIR/.next/"
                  echo "  âœ“ BUILD_ID"
                fi

                # Copy all .json manifest files from .next/ root
                if ls $TEMP_DIR/.next/*.json 1> /dev/null 2>&1; then
                  cp $TEMP_DIR/.next/*.json $DEPLOY_DIR/.next/
                  echo "  âœ“ Copied $(ls $TEMP_DIR/.next/*.json | wc -l) manifest files"
                fi

                # Copy server manifests (.next/server/)
                if [ -d "$TEMP_DIR/.next/server" ]; then
                  mkdir -p $DEPLOY_DIR/.next/server
                  cp -r $TEMP_DIR/.next/server/* $DEPLOY_DIR/.next/server/
                  echo "  âœ“ Server manifests copied"
                fi

                # Move public folder into standalone structure
                echo "Moving public folder..."
                if [ -d "$TEMP_DIR/public" ]; then
                  cp -r $TEMP_DIR/public $DEPLOY_DIR/
                  echo "âœ“ Public folder moved"
                fi

                # Copy deployment scripts
                if [ -d "$TEMP_DIR/scripts" ]; then
                  cp -r $TEMP_DIR/scripts $DEPLOY_DIR/
                fi

                # Remove package.json to prevent Oryx from running build
                echo "Removing package.json to prevent Oryx build..."
                rm -f $DEPLOY_DIR/package.json
                echo "âœ“ package.json removed"

                # Create startup script
                cat > $DEPLOY_DIR/startup.sh <<'EOF'
                #!/bin/bash
                echo "=== Next.js Startup ==="
                echo "Node: $(node --version)"
                echo "Working dir: $(pwd)"

                # Start server directly
                PORT=${PORT:-8080} HOSTNAME=${HOSTNAME:-0.0.0.0} node server.js
                EOF

                chmod +x $DEPLOY_DIR/startup.sh

                # Verification
                echo ""
                echo "=== Deployment Package ==="
                ls -lah $DEPLOY_DIR/
                echo ""
                [ -f "$DEPLOY_DIR/server.js" ] && echo "âœ“ server.js" || echo "âŒ server.js MISSING"
                [ -d "$DEPLOY_DIR/.next" ] && echo "âœ“ .next/" || echo "âŒ .next/ MISSING"

                rm -rf $TEMP_DIR
                echo "âœ“ Ready for deployment"
            displayName: 'Prepare Deployment Package'

          # Create ZIP for deployment
          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/runtime-app'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/runtime-app.zip'
              replaceExistingArchive: true
            displayName: 'Create Deployment ZIP'

          # Publish artifact
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)/runtime-app.zip'
              ArtifactName: 'frontend-drop'
              publishLocation: 'Container'
            displayName: 'Publish Build Artifact'

  # ==========================================================================
  # STAGE 2: Deploy to Azure Web App
  # ==========================================================================
  - stage: Deploy
    displayName: 'Deploy to Azure Web App'
    dependsOn: Build
    condition: succeeded()
    pool:
      vmImage: 'ubuntu-latest'
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy to Linux Web App'
        environment: 'Azure'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: 'frontend-drop'
                  displayName: 'Download Build Artifact'

                # Configure Web App settings BEFORE deployment
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'  # Use variable
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Configuring Azure Web App settings..."
                      echo "Web App: $WEB_APP_NAME"
                      echo "Resource Group: $RESOURCE_GROUP"
                      echo "Runtime BasePath: $RUNTIME_BASEPATH"
                      echo "Backend API URL: $BACKEND_API_URL"
                      echo ""

                      # List current settings BEFORE changes
                      echo "Current app settings (BEFORE):"
                      az webapp config appsettings list \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --query "[?name=='SCM_DO_BUILD_DURING_DEPLOYMENT' || name=='RUNTIME_BASEPATH' || name=='FASTAPI_URL' || name=='ENABLE_ORYX_BUILD'].{Name:name, Value:value}" \
                        --output table

                      echo ""
                      echo "=== Configuring App Settings ==="

                      # CRITICAL: Disable Oryx/Kudu build completely
                      echo ""
                      echo "1. Disabling Oryx build system..."
                      az webapp config appsettings set \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --settings \
                          SCM_DO_BUILD_DURING_DEPLOYMENT=false \
                          ENABLE_ORYX_BUILD=false \
                          WEBSITES_ENABLE_APP_SERVICE_STORAGE=false

                      # Set application environment variables
                      echo ""
                      echo "2. Setting application environment variables..."
                      az webapp config appsettings set \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --settings \
                          RUNTIME_BASEPATH="$RUNTIME_BASEPATH" \
                          FASTAPI_URL="$BACKEND_API_URL" \
                          NODE_ENV=production \
                          WEBSITE_NODE_DEFAULT_VERSION=~22

                      echo ""
                      echo "=== Verifying App Settings (AFTER) ==="
                      az webapp config appsettings list \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --query "[?name=='SCM_DO_BUILD_DURING_DEPLOYMENT' || name=='ENABLE_ORYX_BUILD' || name=='RUNTIME_BASEPATH' || name=='FASTAPI_URL'].{Name:name, Value:value}" \
                        --output table

                      # Check if settings were actually applied
                      echo ""
                      ORYX_DISABLED=$(az webapp config appsettings list \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --query "[?name=='SCM_DO_BUILD_DURING_DEPLOYMENT'].value | [0]" \
                        -o tsv)

                      if [ "$ORYX_DISABLED" != "false" ]; then
                        echo "âš ï¸  WARNING: SCM_DO_BUILD_DURING_DEPLOYMENT is not 'false', current value: '$ORYX_DISABLED'"
                        echo "âš ï¸  Oryx may still clean wwwroot after deployment!"
                      else
                        echo "âœ“ Oryx build correctly disabled"
                      fi

                      # Configure startup command
                      az webapp config set \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --startup-file "startup.sh"

                      echo "âœ“ Startup command configured"

                      # Enable Always On (recommended for production)
                      az webapp config set \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --always-on true

                      echo "âœ“ Always On enabled"
                  env:
                    WEB_APP_NAME: $(webAppName)
                    RESOURCE_GROUP: $(resourceGroup)
                    RUNTIME_BASEPATH: $(runtimeBasePath)
                    BACKEND_API_URL: $(backendApiUrl)
                  displayName: 'Configure Web App Settings'

                # Deploy to Azure Web App using Kudu ZipDeploy API
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "=== Deploying to Azure Web App using Kudu API ==="
                      echo "Web App: $WEB_APP_NAME"
                      echo "Resource Group: $RESOURCE_GROUP"
                      echo "ZIP file: $(Pipeline.Workspace)/frontend-drop/runtime-app.zip"

                      # Get publishing credentials
                      echo "Getting publishing credentials..."
                      CREDS=$(az webapp deployment list-publishing-credentials \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --query "{username:publishingUserName, password:publishingPassword}" \
                        -o json)

                      USERNAME=$(echo $CREDS | jq -r '.username')
                      PASSWORD=$(echo $CREDS | jq -r '.password')

                      echo "Publishing credentials obtained"

                      # Get Kudu URL from Web App properties
                      echo "Getting Kudu URL..."
                      KUDU_URL=$(az webapp show \
                        --name "$WEB_APP_NAME" \
                        --resource-group "$RESOURCE_GROUP" \
                        --query "enabledHostNames" -o tsv | grep -o "[^ ]*\.scm\.[^ ]*" | head -1)

                      if [ -z "$KUDU_URL" ]; then
                        # Fallback: construct from default hostname
                        DEFAULT_HOSTNAME=$(az webapp show \
                          --name "$WEB_APP_NAME" \
                          --resource-group "$RESOURCE_GROUP" \
                          --query "defaultHostName" -o tsv)
                        KUDU_URL=$(echo "$DEFAULT_HOSTNAME" | sed 's/\.azurewebsites\.net/.scm.azurewebsites.net/')
                      fi

                      KUDU_URL="https://$KUDU_URL"
                      echo "Kudu URL: $KUDU_URL"

                      # Deploy using Kudu ZipDeploy API (async mode)
                      echo "Deploying ZIP package (async mode)..."
                      DEPLOY_RESPONSE=$(curl -X POST \
                        -u "$USERNAME:$PASSWORD" \
                        --data-binary @"$(Pipeline.Workspace)/frontend-drop/runtime-app.zip" \
                        -H "Content-Type: application/zip" \
                        -w "\n%{http_code}" \
                        -s \
                        "$KUDU_URL/api/zipdeploy?isAsync=true")

                      HTTP_STATUS=$(echo "$DEPLOY_RESPONSE" | tail -1)
                      DEPLOY_LOCATION=$(echo "$DEPLOY_RESPONSE" | head -1)

                      echo "HTTP Status: $HTTP_STATUS"
                      echo "Deployment ID: $DEPLOY_LOCATION"

                      if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 202 ]; then
                        echo "âœ“ Deployment initiated successfully"

                        # Wait for deployment to complete
                        echo "Waiting for deployment to complete..."
                        MAX_WAIT=120  # 2 minutes max
                        ELAPSED=0

                        while [ $ELAPSED -lt $MAX_WAIT ]; do
                          sleep 5
                          ELAPSED=$((ELAPSED + 5))

                          # Check deployment status
                          STATUS_RESPONSE=$(curl -s -u "$USERNAME:$PASSWORD" \
                            "$KUDU_URL/api/deployments/latest")

                          DEPLOY_STATUS=$(echo "$STATUS_RESPONSE" | jq -r '.status // "unknown"')
                          echo "Status check ($ELAPSED s): $DEPLOY_STATUS"

                          if [ "$DEPLOY_STATUS" = "4" ] || [ "$DEPLOY_STATUS" = "Success" ]; then
                            echo "âœ“ Deployment completed successfully"
                            break
                          elif [ "$DEPLOY_STATUS" = "3" ] || [ "$DEPLOY_STATUS" = "Failed" ]; then
                            echo "âŒ Deployment failed"
                            echo "Error details:"
                            echo "$STATUS_RESPONSE" | jq '.'
                            exit 1
                          fi
                        done

                        if [ $ELAPSED -ge $MAX_WAIT ]; then
                          echo "âš ï¸ Deployment timeout after $MAX_WAIT seconds"
                        fi
                      else
                        echo "âŒ Deployment failed with status $HTTP_STATUS"
                        exit 1
                      fi

                      # Execute prepare-deployment.js via Kudu to replace basePath placeholder
                      echo ""
                      echo "=== Applying basePath Configuration ===="
                      echo "Runtime basePath: ${RUNTIME_BASEPATH:-'(root)'}"

                      # IMPORTANT: ALWAYS run prepare-deployment.js because next.config.js ALWAYS uses
                      # __RUNTIME_BASEPATH__ placeholder in production builds (regardless of NEXT_PUBLIC_BASE_PATH)
                      # When basePath is empty, we need to replace /__RUNTIME_BASEPATH__ with empty string

                      if [ -n "$RUNTIME_BASEPATH" ]; then
                        echo "Running prepare-deployment.js to replace /__RUNTIME_BASEPATH__ with '$RUNTIME_BASEPATH'"
                        COMMAND="RUNTIME_BASEPATH='$RUNTIME_BASEPATH' node scripts/prepare-deployment.js"
                      else
                        echo "Running prepare-deployment.js to replace /__RUNTIME_BASEPATH__ with empty string (root path)"
                        # For empty basePath, use unset variable so prepare-deployment.js uses default empty string
                        COMMAND="node scripts/prepare-deployment.js"
                      fi

                      # Execute Node.js script via Kudu command API
                      PREPARE_RESULT=$(curl -s -u "$USERNAME:$PASSWORD" \
                        -H "Content-Type: application/json" \
                        -X POST \
                        "$KUDU_URL/api/command" \
                        -d "{\"command\": \"$COMMAND\", \"dir\": \"/home/site/wwwroot\"}")

                      echo "Prepare-deployment output:"
                      echo "$PREPARE_RESULT" | jq '.'

                      # Check if command succeeded
                      EXIT_CODE=$(echo "$PREPARE_RESULT" | jq -r '.ExitCode // "1"')
                      if [ "$EXIT_CODE" != "0" ]; then
                        echo "âŒ prepare-deployment.js failed with exit code: $EXIT_CODE"
                        echo "Error output:"
                        echo "$PREPARE_RESULT" | jq -r '.Error'
                        exit 1
                      else
                        echo "âœ“ basePath configuration applied successfully"
                        OUTPUT=$(echo "$PREPARE_RESULT" | jq -r '.Output')
                        if [ -n "$OUTPUT" ]; then
                          echo "$OUTPUT"
                        fi
                      fi

                      # Verify files were extracted
                      echo ""
                      echo "Verifying deployment..."
                      sleep 5

                      # List files in wwwroot via Kudu
                      echo "Files in wwwroot:"
                      curl -s -u "$USERNAME:$PASSWORD" \
                        "$KUDU_URL/api/vfs/site/wwwroot/" \
                        | jq -r '.[].name' || echo "Could not list files"

                      echo ""
                      echo "âœ“ Deployment completed"
                  env:
                    WEB_APP_NAME: $(webAppName)
                    RESOURCE_GROUP: $(resourceGroup)
                  displayName: 'Deploy to Azure Web App'

                # Health check
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Performing health check..."

                      # Get Web App URL
                      APP_URL=$(az webapp show \
                        --name $(webAppName) \
                        --resource-group $(resourceGroup) \
                        --query "defaultHostName" -o tsv)

                      FULL_URL="https://${APP_URL}$(runtimeBasePath)"

                      echo "Testing URL: $FULL_URL"

                      # Wait for deployment to complete and app to start
                      MAX_ATTEMPTS=3
                      ATTEMPT=1
                      SUCCESS=false

                      while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
                        echo "Health check attempt $ATTEMPT of $MAX_ATTEMPTS..."
                        sleep 10

                        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$FULL_URL" || echo "000")

                        if [ "$HTTP_CODE" = "200" ]; then
                          echo "âœ… Application is healthy! (HTTP $HTTP_CODE)"
                          SUCCESS=true
                          break
                        else
                          echo "âš ï¸ Not ready yet (HTTP $HTTP_CODE)..."
                        fi

                        ATTEMPT=$((ATTEMPT + 1))
                      done

                      if [ "$SUCCESS" = "false" ]; then
                        echo ""
                        echo "âŒ Health check failed after $MAX_ATTEMPTS attempts (HTTP $HTTP_CODE)"
                        echo ""
                        echo "Troubleshooting steps:"
                        echo "1. Check app settings are configured:"
                        echo "   az webapp config appsettings list --name $(webAppName) --resource-group $(resourceGroup)"
                        echo ""
                        echo "2. Check application logs:"
                        echo "   az webapp log tail --name $(webAppName) --resource-group $(resourceGroup)"
                        echo ""
                        echo "3. Check deployment logs:"
                        echo "   az webapp log deployment show --name $(webAppName) --resource-group $(resourceGroup)"
                        echo ""
                        exit 1
                      fi

                      echo ""
                      echo "=== Deployment Successful ==="
                      echo "Application URL: $FULL_URL"
                      echo "================================"
                  displayName: 'Health Check'
