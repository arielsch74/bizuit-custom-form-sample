# Azure DevOps Pipeline - Frontend (Next.js) to Azure Web App Linux
# Deploys custom-forms/runtime-app to Azure Web App: bizuit-custom-forms

trigger:
  branches:
    include:
      - main
      - dev
  paths:
    include:
      - custom-forms/runtime-app/**
      - packages/**
      - azure-pipelines-frontend-webapp.yml

variables:
  nodeVersion: '22.x'
  azureSubscription: 'Azure BIZUIT'  # Service Connection name
  webAppName: 'bizuit-custom-forms'
  resourceGroup: 'BIZUIT'

  # Backend API URL (FastAPI)
  backendApiUrl: 'https://bizuit-custom-forms-api-c0c3c9fbb8adafbh.eastus-01.azurewebsites.net'

  # Runtime basePath for deployment
  runtimeBasePath: '/bizuitforms'  # Can be changed as needed

stages:
  # ==========================================================================
  # STAGE 1: Build Next.js Application
  # ==========================================================================
  - stage: Build
    displayName: 'Build Next.js Application'
    pool:
      vmImage: 'ubuntu-latest'  # Linux agent for faster builds
    jobs:
      - job: BuildJob
        displayName: 'Build Runtime App'
        steps:
          - checkout: self
            clean: true
            displayName: 'Checkout Repository'

          - task: NodeTool@0
            inputs:
              versionSpec: '$(nodeVersion)'
            displayName: 'Install Node.js $(nodeVersion)'

          # Cache npm dependencies for faster builds
          - task: Cache@2
            inputs:
              key: 'npm-v2 | "$(Agent.OS)" | custom-forms/runtime-app/package-lock.json'
              restoreKeys: |
                npm-v2 | "$(Agent.OS)"
                npm-v2
              path: '$(Build.SourcesDirectory)/custom-forms/runtime-app/node_modules'
            displayName: 'Cache npm dependencies'

          # Cache Next.js build for faster rebuilds
          - task: Cache@2
            inputs:
              key: 'nextjs-v2 | "$(Agent.OS)" | custom-forms/runtime-app/package-lock.json'
              restoreKeys: |
                nextjs-v2 | "$(Agent.OS)"
                nextjs-v2
              path: '$(Build.SourcesDirectory)/custom-forms/runtime-app/.next/cache'
            displayName: 'Cache Next.js build'
            continueOnError: true

          # Install runtime app dependencies (npm ci fetches published packages from registry)
          - script: |
              cd custom-forms/runtime-app
              npm ci
            displayName: 'Install Runtime App Dependencies'

          # Create .env.local for build (build-time variables)
          - task: Bash@3
            inputs:
              targetType: 'inline'
              workingDirectory: 'custom-forms/runtime-app'
              script: |
                echo "Creating .env.local for build..."
                cat > .env.local <<'EOF'
                # Build-time Environment Variables
                # These are baked into the Next.js build

                # Base path for Azure Web App deployment
                NEXT_PUBLIC_BASE_PATH=$(runtimeBasePath)

                # Bizuit BPM Dashboard API URL (browser connects to BPM)
                NEXT_PUBLIC_BIZUIT_DASHBOARD_API_URL=https://test.bizuit.com/arielschbizuitdashboardapi/api

                # Custom Forms Backend API URL (browser connects to FastAPI backend)
                NEXT_PUBLIC_BIZUIT_FORMS_API_URL=$(backendApiUrl)

                # Timeouts and configuration
                NEXT_PUBLIC_BIZUIT_TIMEOUT=30000
                NEXT_PUBLIC_BIZUIT_TOKEN_EXPIRATION_MINUTES=1440

                # Session timeout
                NEXT_PUBLIC_SESSION_TIMEOUT_MINUTES=30

                # ðŸ”’ CRITICAL SECURITY: Production mode (no dev access)
                NEXT_PUBLIC_ALLOW_DEV_MODE=false

                # Server-side Environment Variables (not baked into build)
                # FASTAPI_URL is used by Next.js API routes (server-side only)
                FASTAPI_URL=$(backendApiUrl)

                # Environment
                NODE_ENV=production
                EOF

                echo "âœ“ .env.local created"
                cat .env.local
            displayName: 'Create Build Environment Configuration'

          # Build Next.js with standalone output
          - task: Npm@1
            inputs:
              command: 'custom'
              customCommand: 'run build'
              workingDir: 'custom-forms/runtime-app'
            displayName: 'Build Next.js Application'
            env:
              NEXT_PUBLIC_BASE_PATH: '$(runtimeBasePath)'
              NODE_ENV: 'production'

          # Copy build files (exclude node_modules - standalone includes only necessary deps)
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)/custom-forms/runtime-app'
              Contents: |
                .next/standalone/**
                .next/static/**
                .next/BUILD_ID
                public/**
                package.json
                scripts/prepare-deployment.js
                !node_modules/**
                !.next/cache/**
              TargetFolder: '$(Build.ArtifactStagingDirectory)/runtime-app-temp'
            displayName: 'Copy Runtime Build Files'

          # Restructure for deployment (standalone needs special structure)
          - task: Bash@3
            inputs:
              targetType: 'inline'
              script: |
                echo "Preparing deployment package..."

                # Move standalone content to root
                if [ -d "$(Build.ArtifactStagingDirectory)/runtime-app-temp/.next/standalone" ]; then
                  mv $(Build.ArtifactStagingDirectory)/runtime-app-temp/.next/standalone $(Build.ArtifactStagingDirectory)/runtime-app

                  # Copy static assets to correct location
                  mkdir -p $(Build.ArtifactStagingDirectory)/runtime-app/.next/static
                  cp -r $(Build.ArtifactStagingDirectory)/runtime-app-temp/.next/static/* $(Build.ArtifactStagingDirectory)/runtime-app/.next/static/

                  # Copy public folder
                  if [ -d "$(Build.ArtifactStagingDirectory)/runtime-app-temp/public" ]; then
                    cp -r $(Build.ArtifactStagingDirectory)/runtime-app-temp/public $(Build.ArtifactStagingDirectory)/runtime-app/
                  fi

                  # Copy deployment scripts
                  if [ -d "$(Build.ArtifactStagingDirectory)/runtime-app-temp/scripts" ]; then
                    cp -r $(Build.ArtifactStagingDirectory)/runtime-app-temp/scripts $(Build.ArtifactStagingDirectory)/runtime-app/
                  fi
                else
                  echo "âŒ Standalone build not found!"
                  exit 1
                fi

                # Create startup script
                cat > $(Build.ArtifactStagingDirectory)/runtime-app/startup.sh <<'STARTUP_EOF'
                #!/bin/bash
                echo "Starting Next.js application..."
                echo "Node version: $(node --version)"
                echo "Working directory: $(pwd)"

                # Run basePath replacement if needed
                if [ -f "scripts/prepare-deployment.js" ] && [ -n "$RUNTIME_BASEPATH" ]; then
                  echo "Applying runtime basePath: $RUNTIME_BASEPATH"
                  node scripts/prepare-deployment.js
                fi

                # Start Next.js server
                export PORT=${PORT:-8080}
                echo "Starting server on port $PORT..."
                node server.js
                STARTUP_EOF

                chmod +x $(Build.ArtifactStagingDirectory)/runtime-app/startup.sh

                # Cleanup temp directory
                rm -rf $(Build.ArtifactStagingDirectory)/runtime-app-temp

                echo "âœ“ Deployment package prepared"
                ls -la $(Build.ArtifactStagingDirectory)/runtime-app/
            displayName: 'Prepare Deployment Package'

          # Create ZIP for deployment
          - task: ArchiveFiles@2
            inputs:
              rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/runtime-app'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/runtime-app.zip'
              replaceExistingArchive: true
            displayName: 'Create Deployment ZIP'

          # Publish artifact
          - task: PublishBuildArtifacts@1
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)/runtime-app.zip'
              ArtifactName: 'frontend-drop'
              publishLocation: 'Container'
            displayName: 'Publish Build Artifact'

  # ==========================================================================
  # STAGE 2: Deploy to Azure Web App
  # ==========================================================================
  - stage: Deploy
    displayName: 'Deploy to Azure Web App'
    dependsOn: Build
    condition: succeeded()
    pool:
      vmImage: 'ubuntu-latest'
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy to Linux Web App'
        environment: 'Azure'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: 'frontend-drop'
                  displayName: 'Download Build Artifact'

                # Configure Web App settings BEFORE deployment
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'  # Use variable
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Configuring Azure Web App settings..."

                      # Set runtime environment variables
                      az webapp config appsettings set \
                        --name $(webAppName) \
                        --resource-group $(resourceGroup) \
                        --settings \
                          RUNTIME_BASEPATH="$(runtimeBasePath)" \
                          FASTAPI_URL="$(backendApiUrl)" \
                          NODE_ENV="production" \
                          WEBSITE_NODE_DEFAULT_VERSION="~22" \
                          SCM_DO_BUILD_DURING_DEPLOYMENT="false" \
                          WEBSITES_ENABLE_APP_SERVICE_STORAGE="false"

                      echo "âœ“ App settings configured"

                      # Configure startup command
                      az webapp config set \
                        --name $(webAppName) \
                        --resource-group $(resourceGroup) \
                        --startup-file "startup.sh"

                      echo "âœ“ Startup command configured"

                      # Enable Always On (recommended for production)
                      az webapp config set \
                        --name $(webAppName) \
                        --resource-group $(resourceGroup) \
                        --always-on true

                      echo "âœ“ Always On enabled"
                  displayName: 'Configure Web App Settings'

                # Deploy to Azure Web App
                - task: AzureWebApp@1
                  inputs:
                    azureSubscription: '$(azureSubscription)'  # Use variable
                    appType: 'webAppLinux'
                    appName: '$(webAppName)'
                    package: '$(Pipeline.Workspace)/frontend-drop/runtime-app.zip'
                    runtimeStack: 'NODE|22-lts'
                    startUpCommand: 'startup.sh'
                  displayName: 'Deploy to Azure Web App'

                # Health check
                - task: AzureCLI@2
                  inputs:
                    azureSubscription: '$(azureSubscription)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Performing health check..."

                      # Get Web App URL
                      APP_URL=$(az webapp show \
                        --name $(webAppName) \
                        --resource-group $(resourceGroup) \
                        --query "defaultHostName" -o tsv)

                      FULL_URL="https://${APP_URL}$(runtimeBasePath)"

                      echo "Testing URL: $FULL_URL"

                      # Wait for deployment to complete and app to start
                      MAX_ATTEMPTS=15
                      ATTEMPT=1
                      SUCCESS=false

                      while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
                        echo "Health check attempt $ATTEMPT of $MAX_ATTEMPTS..."
                        sleep 10

                        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$FULL_URL" || echo "000")

                        if [ "$HTTP_CODE" = "200" ]; then
                          echo "âœ… Application is healthy! (HTTP $HTTP_CODE)"
                          SUCCESS=true
                          break
                        else
                          echo "Not ready yet (HTTP $HTTP_CODE)..."
                        fi

                        ATTEMPT=$((ATTEMPT + 1))
                      done

                      if [ "$SUCCESS" = "false" ]; then
                        echo "âŒ Health check failed after $MAX_ATTEMPTS attempts"
                        echo "Check application logs with: az webapp log tail --name $(webAppName) --resource-group $(resourceGroup)"
                        exit 1
                      fi

                      echo ""
                      echo "=== Deployment Successful ==="
                      echo "Application URL: $FULL_URL"
                      echo "================================"
                  displayName: 'Health Check'
