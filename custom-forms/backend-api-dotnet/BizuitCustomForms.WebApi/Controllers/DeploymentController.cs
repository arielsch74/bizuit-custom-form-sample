using System.IO.Compression;
using System.Text.Json;
using BizuitCustomForms.WebApi.Models;
using BizuitCustomForms.WebApi.Services;
using Microsoft.AspNetCore.Mvc;

namespace BizuitCustomForms.WebApi.Controllers;

[ApiController]
[Route("api/deployment")]
public class DeploymentController : ControllerBase
{
    private readonly IDatabaseService _databaseService;
    private readonly ILogger<DeploymentController> _logger;
    private readonly IConfiguration _configuration;

    // Security limits
    private const long MAX_UPLOAD_SIZE_MB = 50;
    private const long MAX_UPLOAD_SIZE_BYTES = MAX_UPLOAD_SIZE_MB * 1024 * 1024;
    private const int MAX_ZIP_FILES = 1000;
    private const long MAX_ZIP_SIZE_MB = 100;
    private const long MAX_ZIP_SIZE_BYTES = MAX_ZIP_SIZE_MB * 1024 * 1024;

    // Allowed file extensions in ZIP
    private static readonly string[] AllowedExtensions = { ".js", ".json", ".md", ".txt" };

    public DeploymentController(
        IDatabaseService databaseService,
        ILogger<DeploymentController> logger,
        IConfiguration configuration)
    {
        _databaseService = databaseService;
        _logger = logger;
        _configuration = configuration;
    }

    /// <summary>
    /// Upload deployment package (.zip) generated by GitHub Actions
    /// </summary>
    /// <remarks>
    /// **⚠️ Requires admin authentication** - Header: `Authorization: Bearer &lt;token&gt;`
    ///
    /// The .zip file must contain:
    /// - `manifest.json` - Package metadata (version, commit, forms)
    /// - `forms/*.js` - Compiled code for each form
    ///
    /// **Process:**
    /// 1. Validates .zip file (max 50 MB)
    /// 2. Extracts and reads manifest.json
    /// 3. Processes each form individually
    /// 4. Inserts or updates in SQL Server
    /// 5. Returns summary with statistics
    ///
    /// **Response:**
    /// - `success`: Overall operation success
    /// - `message`: Summary message
    /// - `formsProcessed`: Total number of forms in package
    /// - `formsInserted`: New forms added
    /// - `formsUpdated`: Existing forms updated
    /// - `errors`: List of errors (if any)
    /// - `results`: Detail for each processed form
    /// </remarks>
    [HttpPost("upload")]
    public async Task<ActionResult<UploadDeploymentResponse>> UploadDeploymentPackage(IFormFile file)
    {
        // Validations
        if (file == null || file.Length == 0)
        {
            return BadRequest(new UploadDeploymentResponse(
                Success: false,
                Message: "No file uploaded",
                FormsProcessed: 0,
                FormsInserted: 0,
                FormsUpdated: 0,
                Errors: new List<string> { "No file uploaded" }
            ));
        }

        if (!file.FileName.EndsWith(".zip", StringComparison.OrdinalIgnoreCase))
        {
            return BadRequest(new UploadDeploymentResponse(
                Success: false,
                Message: "Only .zip files are allowed",
                FormsProcessed: 0,
                FormsInserted: 0,
                FormsUpdated: 0,
                Errors: new List<string> { "Only .zip files are allowed" }
            ));
        }

        if (file.Length > MAX_UPLOAD_SIZE_BYTES)
        {
            return BadRequest(new UploadDeploymentResponse(
                Success: false,
                Message: $"File size exceeds maximum allowed size of {MAX_UPLOAD_SIZE_MB} MB",
                FormsProcessed: 0,
                FormsInserted: 0,
                FormsUpdated: 0,
                Errors: new List<string> { $"File exceeds {MAX_UPLOAD_SIZE_MB} MB limit" }
            ));
        }

        _logger.LogInformation("[Deployment API] Received upload: {FileName} ({FileSize} bytes)",
            file.FileName, file.Length);

        // Create temp directory for this deployment
        var tempUploadPath = _configuration["TempUploadPath"] ?? "./temp-uploads";
        var tempDir = Path.Combine(tempUploadPath, $"deployment_{DateTime.Now:yyyyMMdd_HHmmss}");
        Directory.CreateDirectory(tempDir);

        var response = new UploadDeploymentResponse(
            Success: false,
            Message: "",
            FormsProcessed: 0,
            FormsInserted: 0,
            FormsUpdated: 0,
            Errors: new List<string>(),
            Results: new List<FormDeploymentResult>()
        );

        try
        {
            // Save .zip temporarily
            var zipPath = Path.Combine(tempDir, file.FileName);
            using (var stream = new FileStream(zipPath, FileMode.Create))
            {
                await file.CopyToAsync(stream);
            }

            // SECURITY: Extract .zip with validations
            var extractDir = Path.Combine(tempDir, "extracted");
            Directory.CreateDirectory(extractDir);

            try
            {
                SafeExtractZip(zipPath, extractDir);
                _logger.LogInformation("[Deployment API] Extracted to: {ExtractDir}", extractDir);
            }
            catch (InvalidOperationException ex)
            {
                // Security validation failed
                return BadRequest(new UploadDeploymentResponse(
                    Success: false,
                    Message: $"Security validation failed: {ex.Message}",
                    FormsProcessed: 0,
                    FormsInserted: 0,
                    FormsUpdated: 0,
                    Errors: new List<string> { ex.Message }
                ));
            }

            // Read manifest.json
            var manifestPath = Path.Combine(extractDir, "manifest.json");
            if (!System.IO.File.Exists(manifestPath))
            {
                throw new FileNotFoundException("manifest.json not found in deployment package");
            }

            var manifestJson = await System.IO.File.ReadAllTextAsync(manifestPath);
            var manifest = JsonSerializer.Deserialize<DeploymentManifest>(manifestJson,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            if (manifest == null)
            {
                throw new InvalidOperationException("Failed to parse manifest.json");
            }

            _logger.LogInformation("[Deployment API] Package version: {PackageVersion}", manifest.PackageVersion);
            _logger.LogInformation("[Deployment API] Forms to process: {Count}", manifest.Forms.Count);

            response = response with { FormsProcessed = manifest.Forms.Count };

            // Process each form
            foreach (var formInfo in manifest.Forms)
            {
                var result = await ProcessFormAsync(formInfo, extractDir, manifest);
                response.Results!.Add(result);

                if (result.Success)
                {
                    if (result.Action == "inserted")
                        response = response with { FormsInserted = response.FormsInserted + 1 };
                    else if (result.Action == "updated")
                        response = response with { FormsUpdated = response.FormsUpdated + 1 };
                }
                else
                {
                    response.Errors!.Add($"{formInfo.FormName}: {result.Error}");
                }
            }

            // Final result
            var success = response.Errors!.Count == 0;
            var message = success
                ? $"Deployment successful: {response.FormsInserted} inserted, {response.FormsUpdated} updated"
                : $"Deployment completed with errors: {response.Errors.Count} failed";

            response = response with { Success = success, Message = message };

            _logger.LogInformation("[Deployment API] {Message}", message);

            return Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[Deployment API] Error processing deployment");

            return StatusCode(500, new UploadDeploymentResponse(
                Success: false,
                Message: $"Deployment failed: {ex.Message}",
                FormsProcessed: response.FormsProcessed,
                FormsInserted: response.FormsInserted,
                FormsUpdated: response.FormsUpdated,
                Errors: new List<string> { ex.Message },
                Results: response.Results
            ));
        }
        finally
        {
            // Cleanup: delete temp directory
            try
            {
                Directory.Delete(tempDir, recursive: true);
                _logger.LogInformation("[Deployment API] Cleaned up temp directory: {TempDir}", tempDir);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "[Deployment API] Failed to cleanup {TempDir}", tempDir);
            }
        }
    }

    private async Task<FormDeploymentResult> ProcessFormAsync(
        FormDeploymentInfo formInfo,
        string extractDir,
        DeploymentManifest manifest)
    {
        try
        {
            // Read compiled code
            var formCodePath = Path.Combine(extractDir, formInfo.Path);
            if (!System.IO.File.Exists(formCodePath))
            {
                throw new FileNotFoundException($"Form file not found: {formInfo.Path}");
            }

            var compiledCode = await System.IO.File.ReadAllTextAsync(formCodePath);

            _logger.LogInformation("[Deployment API] Processing form: {FormName} ({Size} bytes)",
                formInfo.FormName, compiledCode.Length);

            // Parse build date
            DateTime buildDate;
            if (!DateTime.TryParse(manifest.BuildDate, out buildDate))
            {
                // If parsing fails, use current date
                buildDate = DateTime.Now;
                _logger.LogWarning("[Deployment API] Failed to parse build date '{BuildDate}', using current date",
                    manifest.BuildDate);
            }

            // Save to DB using stored procedure
            var (success, action) = await _databaseService.UpsertFormAsync(
                formName: formInfo.FormName,
                processName: formInfo.ProcessName,
                version: formInfo.Version,
                description: formInfo.Description ?? "",
                author: formInfo.Author ?? "System",
                compiledCode: compiledCode,
                sizeBytes: compiledCode.Length,
                packageVersion: manifest.PackageVersion,
                commitHash: manifest.CommitHash,
                buildDate: buildDate,
                releaseNotes: formInfo.ReleaseNotes ?? ""
            );

            _logger.LogInformation("[Deployment API] Form {FormName} {Action} successfully",
                formInfo.FormName, action);

            return new FormDeploymentResult(
                FormName: formInfo.FormName,
                Success: success,
                Action: action,
                Error: null
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "[Deployment API] Error processing form {FormName}", formInfo.FormName);

            return new FormDeploymentResult(
                FormName: formInfo.FormName,
                Success: false,
                Action: "failed",
                Error: ex.Message
            );
        }
    }

    /// <summary>
    /// SECURITY: Extract ZIP with path traversal protection (Zip Slip)
    /// </summary>
    private void SafeExtractZip(string zipPath, string extractDir)
    {
        var extractDirResolved = Path.GetFullPath(extractDir);

        using var archive = ZipFile.OpenRead(zipPath);
        var entries = archive.Entries;

        // SECURITY: Validate number of files
        if (entries.Count > MAX_ZIP_FILES)
        {
            throw new InvalidOperationException(
                $"Zip contains too many files. Max: {MAX_ZIP_FILES}, Found: {entries.Count}");
        }

        // SECURITY: Validate total size
        long totalSize = entries.Sum(e => e.Length);
        if (totalSize > MAX_ZIP_SIZE_BYTES)
        {
            throw new InvalidOperationException(
                $"Uncompressed size exceeds limit. Max: {MAX_ZIP_SIZE_MB} MB, Found: {totalSize / 1024 / 1024} MB");
        }

        foreach (var entry in entries)
        {
            // Skip directories
            if (string.IsNullOrEmpty(entry.Name))
                continue;

            // SECURITY: Validate file extension
            var extension = Path.GetExtension(entry.Name).ToLowerInvariant();
            if (!AllowedExtensions.Contains(extension))
            {
                throw new InvalidOperationException(
                    $"File type not allowed: {entry.FullName} (extension: {extension})");
            }

            // SECURITY: Validate no path traversal
            var destinationPath = Path.GetFullPath(Path.Combine(extractDir, entry.FullName));

            if (!destinationPath.StartsWith(extractDirResolved + Path.DirectorySeparatorChar) &&
                !destinationPath.StartsWith(extractDirResolved + Path.AltDirectorySeparatorChar))
            {
                throw new InvalidOperationException(
                    $"Path traversal attempt detected: {entry.FullName}");
            }

            // SECURITY: Validate no dangerous characters
            if (entry.FullName.Contains("..") ||
                entry.FullName.Contains("~") ||
                entry.FullName.Any(c => Path.GetInvalidPathChars().Contains(c)))
            {
                throw new InvalidOperationException(
                    $"Invalid characters in filename: {entry.FullName}");
            }

            // Extract file
            var destinationDir = Path.GetDirectoryName(destinationPath);
            if (!string.IsNullOrEmpty(destinationDir))
            {
                Directory.CreateDirectory(destinationDir);
            }

            entry.ExtractToFile(destinationPath, overwrite: true);
        }

        _logger.LogInformation("[Deployment API] Safely extracted {Count} files", entries.Count);
    }
}
