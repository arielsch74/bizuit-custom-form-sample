import os
import json
import zipfile
import shutil
from datetime import datetime
from pathlib import Path
from typing import List
from fastapi import FastAPI, File, UploadFile, HTTPException, Request, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer
from fastapi.openapi.utils import get_openapi
from dotenv import load_dotenv
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from models import (
    UploadDeploymentResponse,
    FormDeploymentResult,
    DeploymentManifest,
    AdminLoginRequest,
    AdminLoginResponse,
    ValidateSessionRequest,
    ValidateSessionResponse,
    ValidateFormTokenRequest,
    ValidateFormTokenResponse,
    ValidateDashboardTokenRequest,
    ValidateDashboardTokenResponse,
    DashboardParameters,
    SecurityToken
)
from database import (
    upsert_custom_form,
    test_connection,
    validate_security_token,
    delete_security_token,
    validate_dashboard_token
)
from auth_service import (
    login_to_bizuit,
    validate_admin_user,
    generate_session_token,
    verify_session_token,
    refresh_session_token
)
from middleware import AuthMiddleware
from dependencies import get_current_admin_user

load_dotenv()

app = FastAPI(
    title="BIZUIT Custom Forms API",
    description="""
    ## API for managing dynamic forms in BIZUIT BPM

    This API provides:

    ### üîê Administrator Authentication
    - Login with BIZUIT Dashboard credentials
    - Admin role validation
    - JWT session management (30 minutes)

    ### üì¶ Form Deployment
    - Upload .zip packages generated by GitHub Actions
    - Automatic form versioning
    - SQL Server storage

    ### üé´ Form Token Validation
    - Security token validation (SecurityTokens)
    - Automatic token cleanup when forms close

    ### üìã Form Management
    - List available forms
    - Download compiled code
    - Multi-version support

    ---

    **Authentication required:** All endpoints under `/api/deployment` and `/api/admin`
    require a valid JWT token in the `Authorization: Bearer <token>` header.

    **To obtain a token:** Use the `POST /api/auth/login` endpoint with credentials
    from a user with administrator role.
    """,
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_tags=[
        {
            "name": "Health",
            "description": "Endpoints de salud y estado del sistema"
        },
        {
            "name": "Authentication",
            "description": "Autenticaci√≥n y gesti√≥n de sesiones de administradores"
        },
        {
            "name": "Form Tokens",
            "description": "Validaci√≥n de tokens de seguridad para acceso a formularios"
        },
        {
            "name": "Custom Forms",
            "description": "Gesti√≥n y consulta de formularios customizados"
        },
        {
            "name": "Deployment",
            "description": "Carga y deployment de paquetes de formularios (requiere autenticaci√≥n)"
        }
    ]
)

# CORS configuration
# SECURITY: CORS_ORIGINS environment variable is REQUIRED
# Never use wildcard (*) with allow_credentials=True
cors_origins_env = os.getenv("CORS_ORIGINS")

if not cors_origins_env:
    raise ValueError(
        "CORS_ORIGINS environment variable is required. "
        "Specify allowed origins as comma-separated list (e.g., http://localhost:3000,http://localhost:3001). "
        "Never use '*' in production with credentials enabled."
    )

cors_origins = [origin.strip() for origin in cors_origins_env.split(",")]

# Validate that wildcard is not used with credentials
if "*" in cors_origins:
    raise ValueError(
        "SECURITY ERROR: Cannot use wildcard '*' in CORS_ORIGINS with allow_credentials=True. "
        "This is a critical security vulnerability. "
        "Specify explicit origins instead (e.g., http://localhost:3000,http://localhost:3001)"
    )

app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["Content-Type", "Authorization", "X-Requested-With"],
)

# Authentication middleware
app.add_middleware(AuthMiddleware)

# ==============================================================================
# Rate Limiting Configuration
# ==============================================================================
# SECURITY: Configure rate limiting to prevent brute force and DoS attacks
limiter = Limiter(key_func=get_remote_address, default_limits=["200/hour"])
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Security scheme for Swagger UI
security = HTTPBearer()

# Customize OpenAPI schema to add security
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
    )

    # Initialize components if not exists
    if "components" not in openapi_schema:
        openapi_schema["components"] = {}

    # Add security scheme
    openapi_schema["components"]["securitySchemes"] = {
        "HTTPBearer": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
            "description": "Enter your JWT token obtained from POST /api/auth/login"
        }
    }

    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# Configuration
MAX_UPLOAD_SIZE_MB = int(os.getenv("MAX_UPLOAD_SIZE_MB", "50"))
MAX_UPLOAD_SIZE_BYTES = MAX_UPLOAD_SIZE_MB * 1024 * 1024
TEMP_UPLOAD_PATH = os.getenv("TEMP_UPLOAD_PATH", "./temp-uploads")

# Ensure temp directory exists
Path(TEMP_UPLOAD_PATH).mkdir(parents=True, exist_ok=True)


@app.get("/", tags=["Health"])
def root():
    """
    Basic health check endpoint

    Returns service status and current timestamp.
    """
    return {
        "status": "healthy",
        "service": "BIZUIT Custom Forms API",
        "timestamp": datetime.utcnow().isoformat()
    }


@app.get("/health", tags=["Health"])
def health_check():
    """
    Health check with database connection test

    Verifies service status and SQL Server connectivity.
    """
    db_status = test_connection()
    return {
        "status": "healthy" if db_status["success"] else "degraded",
        "database": db_status,
        "timestamp": datetime.utcnow().isoformat()
    }


# ==============================================================================
# Authentication Endpoints
# ==============================================================================

@app.post("/api/auth/login", response_model=AdminLoginResponse, tags=["Authentication"])
@limiter.limit("5/minute")  # SECURITY: 5 login attempts per minute per IP
async def admin_login(request: Request, credentials: AdminLoginRequest):
    """
    Administrator login

    Authenticates user against BIZUIT Dashboard API and validates admin roles.

    **Flow:**
    1. Validates credentials against BIZUIT API
    2. Verifies user has admin role (configurable in ADMIN_ALLOWED_ROLES)
    3. Generates a JWT session token valid for 30 minutes

    **Returns:**
    - `success`: true if login successful
    - `token`: JWT token for authenticated requests
    - `user`: User information (username, roles, email, etc.)
    - `error`: Error message if failed

    **Example:**
    ```json
    {
      "username": "admin",
      "password": "password123"
    }
    ```
    """
    try:
        # SECURITY: Sanitize username in logs (only show first 3 chars)
        sanitized_username = f"{credentials.username[:3]}***" if len(credentials.username) > 3 else "***"
        print(f"[Auth API] Login attempt for user '{sanitized_username}'")

        # 1. Login to Bizuit API
        bizuit_login = login_to_bizuit(credentials.username, credentials.password)

        if not bizuit_login["success"]:
            print(f"[Auth API] Bizuit login failed: {bizuit_login['error']}")
            return AdminLoginResponse(
                success=False,
                token=None,
                user=None,
                error=bizuit_login["error"]
            )

        # 2. Validate admin roles
        validation = validate_admin_user(credentials.username, bizuit_login["token"])

        if not validation["has_access"]:
            print(f"[Auth API] User '{sanitized_username}' lacks admin permissions")
            return AdminLoginResponse(
                success=False,
                token=None,
                user=None,
                error="Access denied. User does not have administrator privileges."
            )

        # 3. Generate session token
        session_token = generate_session_token(
            credentials.username,
            bizuit_login["token"],
            validation["user_info"]
        )

        # 4. Return success response
        user_data = {
            "username": credentials.username,
            "roles": validation["user_roles"],
            **validation["user_info"]
        }

        print(f"[Auth API] Login successful for '{sanitized_username}'")

        return AdminLoginResponse(
            success=True,
            token=session_token,
            user=user_data,
            error=None
        )

    except Exception as e:
        print(f"[Auth API] Login error: {str(e)}")
        return AdminLoginResponse(
            success=False,
            token=None,
            user=None,
            error=f"Authentication error: {str(e)}"
        )


@app.post("/api/auth/validate", response_model=ValidateSessionResponse, tags=["Authentication"])
async def validate_session(request: ValidateSessionRequest):
    """
    Validate existing session token

    Verifies if a JWT token is still valid (not expired).
    Useful for checking sessions before operations.
    """
    try:
        payload = verify_session_token(request.token)

        if not payload:
            return ValidateSessionResponse(
                valid=False,
                user=None,
                error="Invalid or expired token"
            )

        user_data = {
            "username": payload.get("username"),
            **payload.get("user_info", {})
        }

        return ValidateSessionResponse(
            valid=True,
            user=user_data,
            error=None
        )

    except Exception as e:
        print(f"[Auth API] Validation error: {str(e)}")
        return ValidateSessionResponse(
            valid=False,
            user=None,
            error=str(e)
        )


@app.post("/api/auth/refresh", tags=["Authentication"])
async def refresh_session(request: ValidateSessionRequest):
    """
    Refresh session token (extends expiration)

    Generates a new token with 30 additional minutes of validity.
    Useful for keeping sessions alive with user activity.
    """
    try:
        new_token = refresh_session_token(request.token)

        if not new_token:
            return {
                "success": False,
                "token": None,
                "error": "Cannot refresh invalid or expired token"
            }

        return {
            "success": True,
            "token": new_token,
            "error": None
        }

    except Exception as e:
        print(f"[Auth API] Refresh error: {str(e)}")
        return {
            "success": False,
            "token": None,
            "error": str(e)
        }


# ==============================================================================
# Form Token Validation Endpoints
# ==============================================================================

@app.post("/api/forms/validate-token", response_model=ValidateFormTokenResponse, tags=["Form Tokens"])
@limiter.limit("30/minute")  # SECURITY: 30 token validations per minute per IP
async def validate_form_token(http_request: Request, request: ValidateFormTokenRequest):
    """
    Validate security token for form access

    Verifies token exists in BIZUITPersistenceStore.SecurityTokens and hasn't expired.
    This endpoint does NOT require admin authentication (used by public forms).
    """
    try:
        print(f"[Form Token API] Validating token '{request.tokenId}'")

        token_info = validate_security_token(request.tokenId)

        if not token_info:
            return ValidateFormTokenResponse(
                valid=False,
                token=None,
                error="Token not found"
            )

        # Check if token is expired
        is_valid = token_info.get("is_valid", True)
        if not is_valid:
            return ValidateFormTokenResponse(
                valid=False,
                token=SecurityToken(**token_info),
                error="Token expired"
            )

        return ValidateFormTokenResponse(
            valid=True,
            token=SecurityToken(**token_info),
            error=None
        )

    except Exception as e:
        print(f"[Form Token API] Validation error: {str(e)}")
        return ValidateFormTokenResponse(
            valid=False,
            token=None,
            error=str(e)
        )


@app.delete("/api/forms/close-token/{token_id}", tags=["Form Tokens"])
async def close_form_token(token_id: str):
    """
    Close/delete a security token (when form closes)

    Removes token from BIZUITPersistenceStore.SecurityTokens.
    Called automatically when user closes or completes a form.
    """
    try:
        print(f"[Form Token API] Closing token '{token_id}'")

        deleted = delete_security_token(token_id)

        if deleted:
            return {
                "success": True,
                "message": f"Token '{token_id}' closed successfully"
            }
        else:
            return {
                "success": False,
                "message": f"Token '{token_id}' not found"
            }

    except Exception as e:
        print(f"[Form Token API] Close error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


def validate_dashboard_params(request: ValidateDashboardTokenRequest):
    """
    SECURITY: Valida par√°metros del Dashboard antes de procesarlos

    Validates:
    - instanceId: Numeric, max 20 chars
    - userName: Alphanumeric + @._-, max 100 chars
    - eventName: Alphanumeric + _- and spaces, max 100 chars
    - activityName: Alphanumeric + _- and spaces, max 100 chars
    - token: Base64 format, max 500 chars

    Args:
        request: ValidateDashboardTokenRequest with parameters to validate

    Raises:
        HTTPException: If validation fails
    """
    import re

    # SECURITY: Validar instanceId es num√©rico
    if request.instanceId:
        if not str(request.instanceId).isdigit():
            raise HTTPException(status_code=400, detail="Invalid instanceId format: must be numeric")
        if len(str(request.instanceId)) > 20:
            raise HTTPException(status_code=400, detail="instanceId too long: max 20 characters")

    # SECURITY: Validar userName no contiene caracteres peligrosos
    if request.userName:
        if not re.match(r'^[a-zA-Z0-9_@.\-]+$', request.userName):
            raise HTTPException(status_code=400, detail="Invalid userName format: only alphanumeric, @, ., _, - allowed")
        if len(request.userName) > 100:
            raise HTTPException(status_code=400, detail="userName too long: max 100 characters")

    # SECURITY: Validar eventName
    if request.eventName:
        if not re.match(r'^[a-zA-Z0-9_\-\s]+$', request.eventName):
            raise HTTPException(status_code=400, detail="Invalid eventName format")
        if len(request.eventName) > 100:
            raise HTTPException(status_code=400, detail="eventName too long: max 100 characters")

    # SECURITY: Validar activityName
    if request.activityName:
        if not re.match(r'^[a-zA-Z0-9_\-\s]+$', request.activityName):
            raise HTTPException(status_code=400, detail="Invalid activityName format")
        if len(request.activityName) > 100:
            raise HTTPException(status_code=400, detail="activityName too long: max 100 characters")

    # SECURITY: Validar format de token (Base64)
    if request.token:
        if not re.match(r'^[a-zA-Z0-9+/=]+$', request.token):
            raise HTTPException(status_code=400, detail="Invalid token format: must be Base64")
        if len(request.token) > 500:
            raise HTTPException(status_code=400, detail="token too long: max 500 characters")


@app.post("/api/dashboard/validate-token", response_model=ValidateDashboardTokenResponse, tags=["Form Tokens"])
@limiter.limit("20/minute")  # SECURITY: 20 dashboard token validations per minute per IP
async def validate_dashboard_token_endpoint(http_request: Request, request: ValidateDashboardTokenRequest):
    """
    Validate encrypted token from Bizuit Dashboard and return all parameters for the form

    **Flow:**
    1. Dashboard sends query string with all parameters:
       `?InstanceId=123&UserName=admin&s=aAAV/9xqhAE=&eventName=MyProcess&activityName=Task1&token=xyz`
    2. Runtime-app extracts ALL parameters and calls this endpoint
    3. Backend decrypts the 's' parameter (TripleDES ‚Üí TokenId)
    4. Validates TokenId against SecurityTokens table
    5. Merges query string parameters + SecurityTokens data
    6. Returns complete parameter set for the form to use

    **Parameters from Dashboard:**
    - `s` (required): Encrypted TokenId
    - `InstanceId`: Process instance ID
    - `UserName`: Current user
    - `eventName`: Process/event name (e.g., "[[PROCESS_NAME]]")
    - `activityName`: Activity name (e.g., "[[ACTIVITY_NAME]]")
    - `token`: Auth token (e.g., "[[TOKEN]]")

    **Example Request:**
    ```json
    {
      "encryptedToken": "aAAV/9xqhAE=",
      "instanceId": "12345",
      "userName": "admin",
      "eventName": "VacationRequest",
      "activityName": "ApproveRequest",
      "token": "Basic abc123..."
    }
    ```

    **Example Response (Success):**
    ```json
    {
      "valid": true,
      "parameters": {
        "instanceId": "12345",
        "userName": "admin",
        "eventName": "VacationRequest",
        "activityName": "ApproveRequest",
        "token": "Basic abc123...",
        "tokenId": "131138",
        "operation": 1,
        "requesterAddress": "127.0.0.1",
        "expirationDate": "2025-12-09T15:01:02.790"
      },
      "error": null
    }
    ```

    **Example Response (Failed):**
    ```json
    {
      "valid": false,
      "parameters": null,
      "error": "Token not found or expired"
    }
    ```
    """
    try:
        # SECURITY: Validate all dashboard parameters FIRST
        validate_dashboard_params(request)

        print(f"[Dashboard Token API] Validating encrypted token with parameters:")
        print(f"  - Encrypted token: '{request.encryptedToken[:20]}...'")
        print(f"  - InstanceId: {request.instanceId}")
        print(f"  - UserName: {request.userName}")
        print(f"  - EventName: {request.eventName}")
        print(f"  - ActivityName: {request.activityName}")
        print(f"  - Token: {'present' if request.token else 'not provided'}")

        # 1. Validate encrypted token against SecurityTokens table
        token_info = validate_dashboard_token(request.encryptedToken)

        if not token_info:
            return ValidateDashboardTokenResponse(
                valid=False,
                parameters=None,
                error="Token not found or expired"
            )

        # 2. Merge parameters from query string + SecurityTokens table
        parameters = DashboardParameters(
            # From Dashboard query string
            instanceId=request.instanceId,
            userName=request.userName,
            eventName=request.eventName,
            activityName=request.activityName,
            token=request.token,
            # From SecurityTokens table
            tokenId=str(token_info.get("tokenId")),
            operation=token_info.get("operation"),
            requesterAddress=token_info.get("requesterAddress"),
            expirationDate=token_info.get("expirationDate")
        )

        print(f"[Dashboard Token API] ‚úÖ Token validated successfully")
        print(f"  - TokenId: {parameters.tokenId}")
        print(f"  - User from DB: {token_info.get('userName')}")
        print(f"  - User from query: {parameters.userName}")

        return ValidateDashboardTokenResponse(
            valid=True,
            parameters=parameters,
            error=None
        )

    except ValueError as e:
        print(f"[Dashboard Token API] ‚ùå Decryption error: {str(e)}")
        return ValidateDashboardTokenResponse(
            valid=False,
            parameters=None,
            error=f"Invalid encrypted token: {str(e)}"
        )

    except Exception as e:
        print(f"[Dashboard Token API] ‚ùå Validation error: {str(e)}")
        return ValidateDashboardTokenResponse(
            valid=False,
            parameters=None,
            error=f"Server error: {str(e)}"
        )


# ==============================================================================
# Custom Forms Endpoints
# ==============================================================================

@app.get("/api/custom-forms", tags=["Custom Forms"])
def get_custom_forms():
    """
    Get list of all custom forms

    Returns information about all active forms with their current version.
    Includes: name, associated process, version, description, author, size, dates.
    """
    from database import get_all_custom_forms

    try:
        forms = get_all_custom_forms()
        print(f"[Forms API] Returning {len(forms)} forms")
        return forms
    except Exception as e:
        print(f"[Forms API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch forms: {str(e)}")


@app.get("/api/custom-forms/{form_name}/code", tags=["Custom Forms"])
def get_form_compiled_code(form_name: str, version: str = None):
    """
    Get compiled code for a specific form

    Returns the compiled JavaScript for the form.
    If version not specified, returns current (most recent) version.
    """
    from database import get_form_compiled_code
    from fastapi.responses import Response

    try:
        result = get_form_compiled_code(form_name, version)

        if not result:
            raise HTTPException(status_code=404, detail=f"Form '{form_name}' not found")

        print(f"[Form Code API] Serving {form_name}@{result['version']} ({result['size_bytes']} bytes)")

        return Response(
            content=result['compiled_code'],
            media_type='application/javascript; charset=utf-8',
            headers={
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'X-Form-Version': result['version'],
                'X-Published-At': result['published_at'],
                'X-Size-Bytes': str(result['size_bytes']),
            }
        )
    except HTTPException:
        raise
    except Exception as e:
        print(f"[Form Code API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch form code: {str(e)}")


# ==============================================================================
# Security Functions for File Upload
# ==============================================================================

# Configuration constants
MAX_ZIP_FILES = 100
MAX_ZIP_SIZE_MB = 50
ALLOWED_EXTENSIONS = {'.json', '.js', '.map', '.txt', '.md'}

def safe_extract(zip_file: zipfile.ZipFile, extract_dir: Path) -> List[str]:
    """
    SECURITY: Extrae ZIP validando que no hay path traversal (Zip Slip)

    Validates:
    - No path traversal attempts (../, ..\\)
    - File count limit (max MAX_ZIP_FILES files)
    - Total size limit (max MAX_ZIP_SIZE_MB MB)
    - Allowed file extensions only
    - No dangerous characters in filenames

    Args:
        zip_file: ZipFile object to extract
        extract_dir: Destination directory (must be absolute path)

    Returns:
        List of extracted file paths (relative to extract_dir)

    Raises:
        ValueError: If validation fails (path traversal, too many files, etc.)
    """
    extract_dir = extract_dir.resolve()
    members = zip_file.namelist()

    # SECURITY: Validar n√∫mero de archivos
    if len(members) > MAX_ZIP_FILES:
        raise ValueError(
            f"Zip contains too many files. Max: {MAX_ZIP_FILES}, Found: {len(members)}"
        )

    # SECURITY: Validar tama√±o total
    total_size = sum(zinfo.file_size for zinfo in zip_file.filelist)
    max_size_bytes = MAX_ZIP_SIZE_MB * 1024 * 1024
    if total_size > max_size_bytes:
        raise ValueError(
            f"Zip too large. Max: {MAX_ZIP_SIZE_MB}MB, "
            f"Found: {total_size / 1024 / 1024:.2f}MB"
        )

    extracted_files = []

    for member in members:
        # SECURITY: Validar que el path no sale del directorio (Zip Slip prevention)
        member_path = (extract_dir / member).resolve()

        if not str(member_path).startswith(str(extract_dir)):
            raise ValueError(f"Zip Slip attempt detected: {member}")

        # SECURITY: Validar extensiones permitidas
        file_ext = Path(member).suffix.lower()
        if file_ext and file_ext not in ALLOWED_EXTENSIONS:
            raise ValueError(
                f"Invalid file type in zip: {member} (extension: {file_ext}). "
                f"Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
            )

        # SECURITY: Validar nombres de archivo (no caracteres peligrosos)
        if any(char in member for char in ['..', '~', '\\']):
            raise ValueError(f"Invalid characters in filename: {member}")

        # SECURITY: Prevenir null bytes en nombres de archivo
        if '\x00' in member:
            raise ValueError(f"Null byte in filename: {member}")

        extracted_files.append(member)

    # Si todas las validaciones pasaron, extraer
    zip_file.extractall(extract_dir)

    return extracted_files


@app.post("/api/deployment/upload", response_model=UploadDeploymentResponse, tags=["Deployment"])
async def upload_deployment_package(
    file: UploadFile = File(...),
    current_user: dict = Depends(get_current_admin_user)
):
    """
    Upload deployment package (.zip) generated by GitHub Actions

    **‚ö†Ô∏è Requires admin authentication** - Header: `Authorization: Bearer <token>`

    The .zip file must contain:
    - `manifest.json` - Package metadata (version, commit, forms)
    - `forms/*.js` - Compiled code for each form

    **Process:**
    1. Validates .zip file (max 50 MB)
    2. Extracts and reads manifest.json
    3. Processes each form individually
    4. Inserts or updates in SQL Server
    5. Returns summary with statistics

    **Response:**
    - `formsProcessed`: Total number of forms in package
    - `formsInserted`: New forms added
    - `formsUpdated`: Existing forms updated
    - `errors`: List of errors (if any)
    - `results`: Detail for each processed form
    """

    # Validaciones
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file uploaded")

    if not file.filename.endswith('.zip'):
        raise HTTPException(status_code=400, detail="Only .zip files are allowed")

    # Read file content
    content = await file.read()
    file_size = len(content)

    if file_size > MAX_UPLOAD_SIZE_BYTES:
        raise HTTPException(
            status_code=400,
            detail=f"File size exceeds maximum allowed size of {MAX_UPLOAD_SIZE_MB} MB"
        )

    print(f"[Deployment API] Received upload: {file.filename} ({file_size} bytes)")

    # Crear directorio temporal para este deployment
    temp_dir = Path(TEMP_UPLOAD_PATH) / f"deployment_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    temp_dir.mkdir(parents=True, exist_ok=True)

    response = UploadDeploymentResponse(
        success=False,
        message="",
        formsProcessed=0,
        formsInserted=0,
        formsUpdated=0,
        errors=[],
        results=[]
    )

    try:
        # Guardar .zip temporalmente
        zip_path = temp_dir / file.filename
        with open(zip_path, "wb") as f:
            f.write(content)

        # SECURITY: Extraer .zip con validaciones de seguridad
        extract_dir = temp_dir / "extracted"
        extract_dir.mkdir(parents=True, exist_ok=True)

        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                extracted_files = safe_extract(zip_ref, extract_dir)
                print(f"[Deployment API] Safely extracted {len(extracted_files)} files to: {extract_dir}")
        except ValueError as e:
            # Validaci√≥n de seguridad fall√≥
            raise HTTPException(
                status_code=400,
                detail=f"Security validation failed: {str(e)}"
            )

        print(f"[Deployment API] Extracted to: {extract_dir}")

        # DEBUG: List all extracted files
        all_files = list(extract_dir.glob('**/*'))
        print(f"[Deployment API] Extracted files ({len(all_files)}):")
        for file_path in all_files:
            rel_path = file_path.relative_to(extract_dir)
            print(f"  - {rel_path} {'[DIR]' if file_path.is_dir() else f'[{file_path.stat().st_size} bytes]'}")

        # Leer manifest.json
        manifest_path = extract_dir / "manifest.json"
        print(f"[Deployment API] Looking for manifest at: {manifest_path}")
        print(f"[Deployment API] Manifest exists: {manifest_path.exists()}")
        if not manifest_path.exists():
            raise Exception("manifest.json not found in deployment package")

        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest_data = json.load(f)
            manifest = DeploymentManifest(**manifest_data)

        print(f"[Deployment API] Package version: {manifest.packageVersion}")
        print(f"[Deployment API] Forms to process: {len(manifest.forms)}")

        response.formsProcessed = len(manifest.forms)

        # Procesar cada form
        for form_info in manifest.forms:
            result = await process_form(form_info, extract_dir, manifest)
            response.results.append(result)

            if result.success:
                if result.action == "inserted":
                    response.formsInserted += 1
                elif result.action == "updated":
                    response.formsUpdated += 1
            else:
                response.errors.append(f"{form_info.formName}: {result.error}")

        # Resultado final
        response.success = len(response.errors) == 0
        response.message = (
            f"Deployment successful: {response.formsInserted} inserted, {response.formsUpdated} updated"
            if response.success
            else f"Deployment completed with errors: {len(response.errors)} failed"
        )

        print(f"[Deployment API] {response.message}")

    except Exception as e:
        print(f"[Deployment API] Error: {str(e)}")
        response.success = False
        response.message = f"Deployment failed: {str(e)}"
        response.errors.append(str(e))

    finally:
        # Cleanup: eliminar directorio temporal
        try:
            shutil.rmtree(temp_dir)
            print(f"[Deployment API] Cleaned up temp directory: {temp_dir}")
        except Exception as e:
            print(f"[Deployment API] Warning: Failed to cleanup {temp_dir}: {e}")

    print(f"[Deployment API] Returning response: {response.model_dump_json()}")
    return response


async def process_form(form_info, extract_dir: Path, manifest: DeploymentManifest) -> FormDeploymentResult:
    """
    Procesa un form individual del deployment package
    """
    result = FormDeploymentResult(
        formName=form_info.formName,
        success=False,
        action="failed",
        error=None
    )

    try:
        # Leer c√≥digo compilado
        form_code_path = extract_dir / form_info.path
        if not form_code_path.exists():
            raise Exception(f"Form file not found: {form_info.path}")

        with open(form_code_path, 'r', encoding='utf-8') as f:
            compiled_code = f.read()

        print(f"[Deployment API] Processing form: {form_info.formName} ({len(compiled_code)} bytes)")

        # Guardar en BD usando stored procedure
        db_result = upsert_custom_form(
            form_name=form_info.formName,
            process_name=form_info.processName,
            version=form_info.version,
            description=form_info.description,
            author=form_info.author,
            compiled_code=compiled_code,
            size_bytes=len(compiled_code),
            package_version=manifest.packageVersion,
            commit_hash=manifest.commitHash,
            build_date=manifest.buildDate  # Pass datetime object directly
        )

        result.success = db_result["success"]
        result.action = db_result["action"]

        print(f"[Deployment API] Form {form_info.formName} {result.action} successfully")

    except Exception as e:
        print(f"[Deployment API] Error processing form {form_info.formName}: {str(e)}")
        result.success = False
        result.action = "failed"
        result.error = str(e)

    return result


if __name__ == "__main__":
    import uvicorn

    port = int(os.getenv("API_PORT", "8000"))
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=port,
        reload=True,
        log_level="info"
    )
