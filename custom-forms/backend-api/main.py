import os
import json
import zipfile
import shutil
from datetime import datetime
from pathlib import Path
from typing import List
from fastapi import FastAPI, File, UploadFile, HTTPException, Request, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer
from fastapi.openapi.utils import get_openapi
from dotenv import load_dotenv
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

from models import (
    UploadDeploymentResponse,
    FormDeploymentResult,
    DeploymentManifest,
    AdminLoginRequest,
    AdminLoginResponse,
    ValidateSessionRequest,
    ValidateSessionResponse,
    ValidateFormTokenRequest,
    ValidateFormTokenResponse,
    ValidateDashboardTokenRequest,
    ValidateDashboardTokenResponse,
    DashboardParameters,
    SecurityToken
)
from database import (
    upsert_custom_form,
    test_connection,
    validate_security_token,
    delete_security_token,
    validate_dashboard_token
)
from auth_service import (
    login_to_bizuit,
    validate_admin_user,
    generate_session_token,
    verify_session_token,
    refresh_session_token
)
from middleware import AuthMiddleware
from dependencies import get_current_admin_user

# Load environment variables from .env.local (if exists) or .env
# .env.local takes precedence (Next.js convention)
load_dotenv('.env.local', override=True)
load_dotenv('.env')

app = FastAPI(
    title="BIZUIT Custom Forms API",
    description="""
    ## API for managing dynamic forms in BIZUIT BPM

    This API provides:

    ### üîê Administrator Authentication
    - Login with BIZUIT Dashboard credentials
    - Admin role validation
    - JWT session management (30 minutes)

    ### üì¶ Form Deployment
    - Upload .zip packages generated by GitHub Actions
    - Automatic form versioning
    - SQL Server storage

    ### üé´ Form Token Validation
    - Security token validation (SecurityTokens)
    - Automatic token cleanup when forms close

    ### üìã Form Management
    - List available forms
    - Download compiled code
    - Multi-version support

    ---

    **Authentication required:** All endpoints under `/api/deployment` and `/api/admin`
    require a valid JWT token in the `Authorization: Bearer <token>` header.

    **To obtain a token:** Use the `POST /api/auth/login` endpoint with credentials
    from a user with administrator role.
    """,
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_tags=[
        {
            "name": "Health",
            "description": "Endpoints de salud y estado del sistema"
        },
        {
            "name": "Authentication",
            "description": "Autenticaci√≥n y gesti√≥n de sesiones de administradores"
        },
        {
            "name": "Form Tokens",
            "description": "Validaci√≥n de tokens de seguridad para acceso a formularios"
        },
        {
            "name": "Custom Forms",
            "description": "Gesti√≥n y consulta de formularios customizados"
        },
        {
            "name": "Deployment",
            "description": "Carga y deployment de paquetes de formularios (requiere autenticaci√≥n)"
        }
    ]
)

# CORS configuration
# DEVELOPMENT MODE: Allow all origins
# WARNING: This should be restricted in production!
cors_origins_env = os.getenv("CORS_ORIGINS", "*")

# For development: allow all origins by using regex pattern
# For production: use specific origins from environment variable
if cors_origins_env == "*":
    print("‚ö†Ô∏è  WARNING: CORS is allowing ALL origins (*) - Use only for development!")
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=False,  # Must be False when using wildcard
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["Content-Type", "Authorization", "X-Requested-With"],
    )
else:
    # Production mode: use specific origins
    cors_origins = [origin.strip() for origin in cors_origins_env.split(",")]
    print(f"[CORS] Configured for specific origins: {cors_origins}")
    app.add_middleware(
        CORSMiddleware,
        allow_origins=cors_origins,
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["Content-Type", "Authorization", "X-Requested-With"],
    )

# Authentication middleware
app.add_middleware(AuthMiddleware)

# ==============================================================================
# Rate Limiting Configuration
# ==============================================================================
# SECURITY: Configure rate limiting to prevent brute force and DoS attacks
limiter = Limiter(key_func=get_remote_address, default_limits=["200/hour"])
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Security scheme for Swagger UI
security = HTTPBearer()

# Customize OpenAPI schema to add security
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title=app.title,
        version=app.version,
        description=app.description,
        routes=app.routes,
    )

    # Initialize components if not exists
    if "components" not in openapi_schema:
        openapi_schema["components"] = {}

    # Add security scheme
    openapi_schema["components"]["securitySchemes"] = {
        "HTTPBearer": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
            "description": "Enter your JWT token obtained from POST /api/auth/login"
        }
    }

    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# Configuration
MAX_UPLOAD_SIZE_MB = int(os.getenv("MAX_UPLOAD_SIZE_MB", "50"))
MAX_UPLOAD_SIZE_BYTES = MAX_UPLOAD_SIZE_MB * 1024 * 1024
TEMP_UPLOAD_PATH = os.getenv("TEMP_UPLOAD_PATH", "./temp-uploads")

# Ensure temp directory exists
Path(TEMP_UPLOAD_PATH).mkdir(parents=True, exist_ok=True)


@app.get("/", tags=["Health"])
def root():
    """
    Basic health check endpoint

    Returns service status and current timestamp.
    """
    return {
        "status": "healthy",
        "service": "BIZUIT Custom Forms API",
        "timestamp": datetime.utcnow().isoformat()
    }


@app.get("/health", tags=["Health"])
def health_check():
    """
    Health check with database connection test

    Verifies service status and SQL Server connectivity.
    """
    db_status = test_connection()
    return {
        "status": "healthy" if db_status["success"] else "degraded",
        "database": db_status,
        "timestamp": datetime.utcnow().isoformat()
    }


# ==============================================================================
# Authentication Endpoints
# ==============================================================================

@app.post("/api/auth/login", response_model=AdminLoginResponse, tags=["Authentication"])
@limiter.limit("5/minute")  # SECURITY: 5 login attempts per minute per IP
async def admin_login(request: Request, credentials: AdminLoginRequest):
    """
    Administrator login

    Authenticates user against BIZUIT Dashboard API and validates admin roles.

    **Flow:**
    1. Validates credentials against BIZUIT API
    2. Verifies user has admin role (configurable in ADMIN_ALLOWED_ROLES)
    3. Generates a JWT session token valid for 30 minutes

    **Returns:**
    - `success`: true if login successful
    - `token`: JWT token for authenticated requests
    - `user`: User information (username, roles, email, etc.)
    - `error`: Error message if failed

    **Example:**
    ```json
    {
      "username": "admin",
      "password": "password123"
    }
    ```
    """
    try:
        # SECURITY: Sanitize username in logs (only show first 3 chars)
        sanitized_username = f"{credentials.username[:3]}***" if len(credentials.username) > 3 else "***"
        print(f"[Auth API] Login attempt for user '{sanitized_username}'")

        # 1. Login to Bizuit API
        bizuit_login = login_to_bizuit(credentials.username, credentials.password)

        if not bizuit_login["success"]:
            print(f"[Auth API] Bizuit login failed: {bizuit_login['error']}")
            return AdminLoginResponse(
                success=False,
                token=None,
                user=None,
                error=bizuit_login["error"]
            )

        # 2. Validate admin roles
        validation = validate_admin_user(credentials.username, bizuit_login["token"])

        if not validation["has_access"]:
            print(f"[Auth API] User '{sanitized_username}' lacks admin permissions")
            return AdminLoginResponse(
                success=False,
                token=None,
                user=None,
                error="Access denied. User does not have administrator privileges."
            )

        # 3. Generate session token
        session_token = generate_session_token(
            credentials.username,
            bizuit_login["token"],
            validation["user_info"]
        )

        # 4. Return success response
        user_data = {
            "username": credentials.username,
            "roles": validation["user_roles"],
            **validation["user_info"]
        }

        print(f"[Auth API] Login successful for '{sanitized_username}'")

        return AdminLoginResponse(
            success=True,
            token=session_token,
            user=user_data,
            error=None
        )

    except Exception as e:
        print(f"[Auth API] Login error: {str(e)}")
        return AdminLoginResponse(
            success=False,
            token=None,
            user=None,
            error=f"Authentication error: {str(e)}"
        )


@app.post("/api/auth/validate", response_model=ValidateSessionResponse, tags=["Authentication"])
async def validate_session(request: ValidateSessionRequest):
    """
    Validate existing session token

    Verifies if a JWT token is still valid (not expired).
    Useful for checking sessions before operations.
    """
    try:
        payload = verify_session_token(request.token)

        if not payload:
            return ValidateSessionResponse(
                valid=False,
                user=None,
                error="Invalid or expired token"
            )

        user_data = {
            "username": payload.get("username"),
            **payload.get("user_info", {})
        }

        return ValidateSessionResponse(
            valid=True,
            user=user_data,
            error=None
        )

    except Exception as e:
        print(f"[Auth API] Validation error: {str(e)}")
        return ValidateSessionResponse(
            valid=False,
            user=None,
            error=str(e)
        )


@app.post("/api/auth/refresh", tags=["Authentication"])
async def refresh_session(request: ValidateSessionRequest):
    """
    Refresh session token (extends expiration)

    Generates a new token with 30 additional minutes of validity.
    Useful for keeping sessions alive with user activity.
    """
    try:
        new_token = refresh_session_token(request.token)

        if not new_token:
            return {
                "success": False,
                "token": None,
                "error": "Cannot refresh invalid or expired token"
            }

        return {
            "success": True,
            "token": new_token,
            "error": None
        }

    except Exception as e:
        print(f"[Auth API] Refresh error: {str(e)}")
        return {
            "success": False,
            "token": None,
            "error": str(e)
        }


# ==============================================================================
# Form Token Validation Endpoints
# ==============================================================================

@app.post("/api/forms/validate-token", response_model=ValidateFormTokenResponse, tags=["Form Tokens"])
@limiter.limit("30/minute")  # SECURITY: 30 token validations per minute per IP
async def validate_form_token(http_request: Request, request: ValidateFormTokenRequest):
    """
    Validate security token for form access

    Verifies token exists in BIZUITPersistenceStore.SecurityTokens and hasn't expired.
    This endpoint does NOT require admin authentication (used by public forms).
    """
    try:
        print(f"[Form Token API] Validating token '{request.tokenId}'")

        token_info = validate_security_token(request.tokenId)

        if not token_info:
            return ValidateFormTokenResponse(
                valid=False,
                token=None,
                error="Token not found"
            )

        # Check if token is expired
        is_valid = token_info.get("is_valid", True)
        if not is_valid:
            return ValidateFormTokenResponse(
                valid=False,
                token=SecurityToken(**token_info),
                error="Token expired"
            )

        return ValidateFormTokenResponse(
            valid=True,
            token=SecurityToken(**token_info),
            error=None
        )

    except Exception as e:
        print(f"[Form Token API] Validation error: {str(e)}")
        return ValidateFormTokenResponse(
            valid=False,
            token=None,
            error=str(e)
        )


@app.delete("/api/forms/close-token/{token_id}", tags=["Form Tokens"])
async def close_form_token(token_id: str):
    """
    Close/delete a security token (when form closes)

    Removes token from BIZUITPersistenceStore.SecurityTokens.
    Called automatically when user closes or completes a form.
    """
    try:
        print(f"[Form Token API] Closing token '{token_id}'")

        deleted = delete_security_token(token_id)

        if deleted:
            return {
                "success": True,
                "message": f"Token '{token_id}' closed successfully"
            }
        else:
            return {
                "success": False,
                "message": f"Token '{token_id}' not found"
            }

    except Exception as e:
        print(f"[Form Token API] Close error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


def validate_dashboard_params(request: ValidateDashboardTokenRequest):
    """
    SECURITY: Valida par√°metros del Dashboard antes de procesarlos

    Validates:
    - instanceId: Numeric, max 20 chars
    - userName: Alphanumeric + @._-, max 100 chars
    - eventName: Alphanumeric + _- and spaces, max 100 chars
    - activityName: Alphanumeric + _- and spaces, max 100 chars
    - token: Base64 format, max 500 chars

    Args:
        request: ValidateDashboardTokenRequest with parameters to validate

    Raises:
        HTTPException: If validation fails
    """
    import re

    # SECURITY: Validar instanceId es num√©rico
    if request.instanceId:
        if not str(request.instanceId).isdigit():
            raise HTTPException(status_code=400, detail="Invalid instanceId format: must be numeric")
        if len(str(request.instanceId)) > 20:
            raise HTTPException(status_code=400, detail="instanceId too long: max 20 characters")

    # SECURITY: Validar userName no contiene caracteres peligrosos
    if request.userName:
        if not re.match(r'^[a-zA-Z0-9_@.\-]+$', request.userName):
            raise HTTPException(status_code=400, detail="Invalid userName format: only alphanumeric, @, ., _, - allowed")
        if len(request.userName) > 100:
            raise HTTPException(status_code=400, detail="userName too long: max 100 characters")

    # SECURITY: Validar eventName
    if request.eventName:
        if not re.match(r'^[a-zA-Z0-9_\-\s]+$', request.eventName):
            raise HTTPException(status_code=400, detail="Invalid eventName format")
        if len(request.eventName) > 100:
            raise HTTPException(status_code=400, detail="eventName too long: max 100 characters")

    # SECURITY: Validar activityName
    if request.activityName:
        if not re.match(r'^[a-zA-Z0-9_\-\s]+$', request.activityName):
            raise HTTPException(status_code=400, detail="Invalid activityName format")
        if len(request.activityName) > 100:
            raise HTTPException(status_code=400, detail="activityName too long: max 100 characters")

    # SECURITY: Validar format de token (Base64, Bearer, Basic, etc.)
    # Allow spaces for "Basic xyz", "Bearer xyz", etc.
    if request.token:
        if not re.match(r'^[a-zA-Z0-9+/=\s]+$', request.token):
            raise HTTPException(status_code=400, detail="Invalid token format: only alphanumeric, +, /, =, and spaces allowed")
        if len(request.token) > 500:
            raise HTTPException(status_code=400, detail="token too long: max 500 characters")


@app.post("/api/dashboard/validate-token", response_model=ValidateDashboardTokenResponse, tags=["Form Tokens"])
@limiter.limit("20/minute")  # SECURITY: 20 dashboard token validations per minute per IP
async def validate_dashboard_token_endpoint(request: Request, data: ValidateDashboardTokenRequest):
    """
    Validate encrypted token from Bizuit Dashboard and return all parameters for the form

    **Flow:**
    1. Dashboard sends query string with all parameters:
       `?InstanceId=123&UserName=admin&s=aAAV/9xqhAE=&eventName=MyProcess&activityName=Task1&token=xyz`
    2. Runtime-app extracts ALL parameters and calls this endpoint
    3. Backend decrypts the 's' parameter (TripleDES ‚Üí TokenId)
    4. Validates TokenId against SecurityTokens table
    5. Merges query string parameters + SecurityTokens data
    6. Returns complete parameter set for the form to use

    **Parameters from Dashboard:**
    - `s` (required): Encrypted TokenId
    - `InstanceId`: Process instance ID
    - `UserName`: Current user
    - `eventName`: Process/event name (e.g., "[[PROCESS_NAME]]")
    - `activityName`: Activity name (e.g., "[[ACTIVITY_NAME]]")
    - `token`: Auth token (e.g., "[[TOKEN]]")

    **Example Request:**
    ```json
    {
      "encryptedToken": "aAAV/9xqhAE=",
      "instanceId": "12345",
      "userName": "admin",
      "eventName": "VacationRequest",
      "activityName": "ApproveRequest",
      "token": "Basic abc123..."
    }
    ```

    **Example Response (Success):**
    ```json
    {
      "valid": true,
      "parameters": {
        "instanceId": "12345",
        "userName": "admin",
        "eventName": "VacationRequest",
        "activityName": "ApproveRequest",
        "token": "Basic abc123...",
        "tokenId": "131138",
        "operation": 1,
        "requesterAddress": "127.0.0.1",
        "expirationDate": "2025-12-09T15:01:02.790"
      },
      "error": null
    }
    ```

    **Example Response (Failed):**
    ```json
    {
      "valid": false,
      "parameters": null,
      "error": "Token not found or expired"
    }
    ```
    """
    try:
        # SECURITY: Validate all dashboard parameters FIRST
        validate_dashboard_params(data)

        print(f"[Dashboard Token API] Validating encrypted token with parameters:")
        print(f"  - Encrypted token: '{data.encryptedToken[:20]}...'")
        print(f"  - InstanceId: {data.instanceId}")
        print(f"  - UserName: {data.userName}")
        print(f"  - EventName: {data.eventName}")
        print(f"  - ActivityName: {data.activityName}")
        print(f"  - Token: {'present' if data.token else 'not provided'}")

        # 1. Validate encrypted token against SecurityTokens table
        token_info = validate_dashboard_token(data.encryptedToken)

        if not token_info:
            return ValidateDashboardTokenResponse(
                valid=False,
                parameters=None,
                error="Token not found or expired"
            )

        # 2. Merge parameters from query string + SecurityTokens table
        parameters = DashboardParameters(
            # From Dashboard query string
            instanceId=data.instanceId,
            userName=data.userName,
            eventName=data.eventName,
            activityName=data.activityName,
            token=data.token,
            # From SecurityTokens table
            tokenId=str(token_info.get("tokenId")),
            operation=token_info.get("operation"),
            requesterAddress=token_info.get("requesterAddress"),
            expirationDate=token_info.get("expirationDate")
        )

        print(f"[Dashboard Token API] Token validated successfully")
        print(f"  - TokenId: {parameters.tokenId}")
        print(f"  - User from DB: {token_info.get('userName')}")
        print(f"  - User from query: {parameters.userName}")

        return ValidateDashboardTokenResponse(
            valid=True,
            parameters=parameters,
            error=None
        )

    except ValueError as e:
        print(f"[Dashboard Token API] ERROR - Decryption error: {str(e)}")
        return ValidateDashboardTokenResponse(
            valid=False,
            parameters=None,
            error=f"Invalid encrypted token: {str(e)}"
        )

    except Exception as e:
        print(f"[Dashboard Token API] ERROR - Validation error: {str(e)}")
        return ValidateDashboardTokenResponse(
            valid=False,
            parameters=None,
            error=f"Server error: {str(e)}"
        )


# ==============================================================================
# Custom Forms Endpoints
# ==============================================================================

@app.get("/api/custom-forms", tags=["Custom Forms"])
def get_custom_forms():
    """
    Get list of all custom forms

    Returns information about all active forms with their current version.
    Includes: name, associated process, version, description, author, size, dates.
    """
    from database import get_all_custom_forms

    try:
        forms = get_all_custom_forms()
        print(f"[Forms API] Returning {len(forms)} forms")
        return forms
    except Exception as e:
        print(f"[Forms API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch forms: {str(e)}")


@app.get("/api/custom-forms/{form_name}/code", tags=["Custom Forms"])
def get_form_compiled_code_endpoint(form_name: str, version: str = None):
    """
    Get compiled code for a specific form

    Returns the compiled JavaScript for the form.
    If version not specified, returns current (most recent) version.

    Args:
        form_name: Name of the form (path parameter)
        version: Optional version string (query parameter, e.g., ?version=1.1.5)
    """
    from database import get_form_compiled_code
    from fastapi.responses import Response

    try:
        print(f"[Form Code API] Request for '{form_name}' version: {version or 'current'}")
        result = get_form_compiled_code(form_name, version)

        if not result:
            raise HTTPException(status_code=404, detail=f"Form '{form_name}' not found")

        print(f"[Form Code API] Serving {form_name}@{result['version']} ({result['size_bytes']} bytes)")

        return Response(
            content=result['compiled_code'],
            media_type='application/javascript; charset=utf-8',
            headers={
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'X-Form-Version': result['version'],
                'X-Published-At': result['published_at'],
                'X-Size-Bytes': str(result['size_bytes']),
            }
        )
    except HTTPException:
        raise
    except Exception as e:
        print(f"[Form Code API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch form code: {str(e)}")


@app.get("/api/custom-forms/{form_name}/versions", tags=["Custom Forms"])
def get_form_versions_api(form_name: str):
    """
    Get all versions for a specific form

    Returns list of all versions with metadata (size, date, isCurrent, etc.)
    """
    from database import get_form_versions

    try:
        versions = get_form_versions(form_name)

        if not versions:
            raise HTTPException(status_code=404, detail=f"Form '{form_name}' not found or has no versions")

        print(f"[Form Versions API] Returning {len(versions)} versions for '{form_name}'")
        return versions
    except ValueError as e:
        # Invalid format
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        print(f"[Form Versions API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch form versions: {str(e)}")


@app.post("/api/custom-forms/{form_name}/set-version", tags=["Custom Forms"])
def set_form_version_api(form_name: str, version: str):
    """
    Set a specific version as the current/active version

    Args:
        form_name: Name of the form
        version: Version to set as current (query parameter)

    Returns:
        Success message
    """
    from database import set_current_form_version

    try:
        result = set_current_form_version(form_name, version)
        print(f"[Set Version API] Set '{form_name}' to version '{version}'")
        return result
    except ValueError as e:
        # Invalid format or version not found
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        print(f"[Set Version API] Error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to set form version: {str(e)}")


# ==============================================================================
# Security Functions for File Upload
# ==============================================================================

# Configuration constants
MAX_ZIP_FILES = 100
MAX_ZIP_SIZE_MB = 50
ALLOWED_EXTENSIONS = {'.json', '.js', '.map', '.txt', '.md'}

def safe_extract(zip_file: zipfile.ZipFile, extract_dir: Path) -> List[str]:
    """
    SECURITY: Extrae ZIP validando que no hay path traversal (Zip Slip)

    Validates:
    - No path traversal attempts (../, ..\\)
    - File count limit (max MAX_ZIP_FILES files)
    - Total size limit (max MAX_ZIP_SIZE_MB MB)
    - Allowed file extensions only
    - No dangerous characters in filenames

    Args:
        zip_file: ZipFile object to extract
        extract_dir: Destination directory (must be absolute path)

    Returns:
        List of extracted file paths (relative to extract_dir)

    Raises:
        ValueError: If validation fails (path traversal, too many files, etc.)
    """
    extract_dir = extract_dir.resolve()
    members = zip_file.namelist()

    # SECURITY: Validar n√∫mero de archivos
    if len(members) > MAX_ZIP_FILES:
        raise ValueError(
            f"Zip contains too many files. Max: {MAX_ZIP_FILES}, Found: {len(members)}"
        )

    # SECURITY: Validar tama√±o total
    total_size = sum(zinfo.file_size for zinfo in zip_file.filelist)
    max_size_bytes = MAX_ZIP_SIZE_MB * 1024 * 1024
    if total_size > max_size_bytes:
        raise ValueError(
            f"Zip too large. Max: {MAX_ZIP_SIZE_MB}MB, "
            f"Found: {total_size / 1024 / 1024:.2f}MB"
        )

    extracted_files = []

    for member in members:
        # SECURITY: Validar que el path no sale del directorio (Zip Slip prevention)
        member_path = (extract_dir / member).resolve()

        if not str(member_path).startswith(str(extract_dir)):
            raise ValueError(f"Zip Slip attempt detected: {member}")

        # SECURITY: Validar extensiones permitidas
        file_ext = Path(member).suffix.lower()
        if file_ext and file_ext not in ALLOWED_EXTENSIONS:
            raise ValueError(
                f"Invalid file type in zip: {member} (extension: {file_ext}). "
                f"Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
            )

        # SECURITY: Validar nombres de archivo (no caracteres peligrosos)
        if any(char in member for char in ['..', '~', '\\']):
            raise ValueError(f"Invalid characters in filename: {member}")

        # SECURITY: Prevenir null bytes en nombres de archivo
        if '\x00' in member:
            raise ValueError(f"Null byte in filename: {member}")

        extracted_files.append(member)

    # Si todas las validaciones pasaron, extraer
    zip_file.extractall(extract_dir)

    return extracted_files


@app.post("/api/deployment/upload", response_model=UploadDeploymentResponse, tags=["Deployment"])
async def upload_deployment_package(
    file: UploadFile = File(...),
    current_user: dict = Depends(get_current_admin_user)
):
    """
    Upload deployment package (.zip) generated by GitHub Actions

    **‚ö†Ô∏è Requires admin authentication** - Header: `Authorization: Bearer <token>`

    The .zip file must contain:
    - `manifest.json` - Package metadata (version, commit, forms)
    - `forms/*.js` - Compiled code for each form

    **Process:**
    1. Validates .zip file (max 50 MB)
    2. Extracts and reads manifest.json
    3. Processes each form individually
    4. Inserts or updates in SQL Server
    5. Returns summary with statistics

    **Response:**
    - `formsProcessed`: Total number of forms in package
    - `formsInserted`: New forms added
    - `formsUpdated`: Existing forms updated
    - `errors`: List of errors (if any)
    - `results`: Detail for each processed form
    """

    # Validaciones
    if not file.filename:
        raise HTTPException(status_code=400, detail="No file uploaded")

    if not file.filename.endswith('.zip'):
        raise HTTPException(status_code=400, detail="Only .zip files are allowed")

    # Read file content
    content = await file.read()
    file_size = len(content)

    if file_size > MAX_UPLOAD_SIZE_BYTES:
        raise HTTPException(
            status_code=400,
            detail=f"File size exceeds maximum allowed size of {MAX_UPLOAD_SIZE_MB} MB"
        )

    print(f"[Deployment API] Received upload: {file.filename} ({file_size} bytes)")

    # Crear directorio temporal para este deployment
    temp_dir = Path(TEMP_UPLOAD_PATH) / f"deployment_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    temp_dir.mkdir(parents=True, exist_ok=True)

    response = UploadDeploymentResponse(
        success=False,
        message="",
        formsProcessed=0,
        formsInserted=0,
        formsUpdated=0,
        errors=[],
        results=[]
    )

    try:
        # Guardar .zip temporalmente
        zip_path = temp_dir / file.filename
        with open(zip_path, "wb") as f:
            f.write(content)

        # SECURITY: Extraer .zip con validaciones de seguridad
        extract_dir = temp_dir / "extracted"
        extract_dir.mkdir(parents=True, exist_ok=True)

        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                extracted_files = safe_extract(zip_ref, extract_dir)
                print(f"[Deployment API] Safely extracted {len(extracted_files)} files to: {extract_dir}")
        except ValueError as e:
            # Validaci√≥n de seguridad fall√≥
            raise HTTPException(
                status_code=400,
                detail=f"Security validation failed: {str(e)}"
            )

        print(f"[Deployment API] Extracted to: {extract_dir}")

        # DEBUG: List all extracted files
        all_files = list(extract_dir.glob('**/*'))
        print(f"[Deployment API] Extracted files ({len(all_files)}):")
        for file_path in all_files:
            rel_path = file_path.relative_to(extract_dir)
            print(f"  - {rel_path} {'[DIR]' if file_path.is_dir() else f'[{file_path.stat().st_size} bytes]'}")

        # Leer manifest.json
        manifest_path = extract_dir / "manifest.json"
        print(f"[Deployment API] Looking for manifest at: {manifest_path}")
        print(f"[Deployment API] Manifest exists: {manifest_path.exists()}")
        if not manifest_path.exists():
            raise Exception("manifest.json not found in deployment package")

        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest_data = json.load(f)
            manifest = DeploymentManifest(**manifest_data)

        print(f"[Deployment API] Package version: {manifest.packageVersion}")
        print(f"[Deployment API] Forms to process: {len(manifest.forms)}")

        response.formsProcessed = len(manifest.forms)

        # Procesar cada form
        for form_info in manifest.forms:
            result = await process_form(form_info, extract_dir, manifest)
            response.results.append(result)

            if result.success:
                if result.action == "inserted":
                    response.formsInserted += 1
                elif result.action == "updated":
                    response.formsUpdated += 1
            else:
                response.errors.append(f"{form_info.formName}: {result.error}")

        # Resultado final
        response.success = len(response.errors) == 0
        response.message = (
            f"Deployment successful: {response.formsInserted} inserted, {response.formsUpdated} updated"
            if response.success
            else f"Deployment completed with errors: {len(response.errors)} failed"
        )

        print(f"[Deployment API] {response.message}")

    except Exception as e:
        print(f"[Deployment API] Error: {str(e)}")
        response.success = False
        response.message = f"Deployment failed: {str(e)}"
        response.errors.append(str(e))

    finally:
        # Cleanup: eliminar directorio temporal
        try:
            shutil.rmtree(temp_dir)
            print(f"[Deployment API] Cleaned up temp directory: {temp_dir}")
        except Exception as e:
            print(f"[Deployment API] Warning: Failed to cleanup {temp_dir}: {e}")

    print(f"[Deployment API] Returning response: {response.model_dump_json()}")
    return response


async def process_form(form_info, extract_dir: Path, manifest: DeploymentManifest) -> FormDeploymentResult:
    """
    Procesa un form individual del deployment package
    """
    result = FormDeploymentResult(
        formName=form_info.formName,
        success=False,
        action="failed",
        error=None
    )

    try:
        # Leer c√≥digo compilado
        form_code_path = extract_dir / form_info.path
        if not form_code_path.exists():
            raise Exception(f"Form file not found: {form_info.path}")

        with open(form_code_path, 'r', encoding='utf-8') as f:
            compiled_code = f.read()

        print(f"[Deployment API] Processing form: {form_info.formName} ({len(compiled_code)} bytes)")

        # Guardar en BD usando stored procedure
        db_result = upsert_custom_form(
            form_name=form_info.formName,
            process_name=form_info.processName,
            version=form_info.version,
            description=form_info.description,
            author=form_info.author,
            compiled_code=compiled_code,
            size_bytes=len(compiled_code),
            package_version=manifest.packageVersion,
            commit_hash=manifest.commitHash,
            build_date=manifest.buildDate,  # Pass datetime object directly
            release_notes=form_info.releaseNotes or ""
        )

        result.success = db_result["success"]
        result.action = db_result["action"]

        print(f"[Deployment API] Form {form_info.formName} {result.action} successfully")

    except Exception as e:
        print(f"[Deployment API] Error processing form {form_info.formName}: {str(e)}")
        result.success = False
        result.action = "failed"
        result.error = str(e)

    return result


if __name__ == "__main__":
    import uvicorn

    port = int(os.getenv("API_PORT", "8000"))

    # Detect production environment
    is_production = (
        os.getenv("NODE_ENV") == "production" or
        os.getenv("PYTHON_ENV") == "production" or
        os.getenv("ENVIRONMENT") == "production"
    )

    # Production configuration
    if is_production:
        print("=" * 50)
        print("Starting FastAPI in PRODUCTION mode")
        print(f"Port: {port}")
        print(f"Workers: 1 (PM2 managed)")
        print(f"Reload: Disabled")
        print("=" * 50)

        uvicorn.run(
            "main:app",
            host="0.0.0.0",
            port=port,
            reload=False,  # NO reload in production
            log_level="info",
            access_log=True,
            timeout_keep_alive=120,
            limit_concurrency=1000,
            limit_max_requests=10000  # Restart worker after 10K requests
        )
    else:
        # Development configuration
        print("=" * 50)
        print("Starting FastAPI in DEVELOPMENT mode")
        print(f"Port: {port}")
        print(f"Reload: Enabled")
        print("=" * 50)

        uvicorn.run(
            "main:app",
            host="0.0.0.0",
            port=port,
            reload=True,
            log_level="debug"
        )
