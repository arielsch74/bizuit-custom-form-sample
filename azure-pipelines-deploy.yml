# Azure DevOps Pipeline - Migrations and Deployment
# Deploys to E:\BIZUITSites\arielsch\arielschBIZUITCustomForms (runtime) and arielschBIZUITCustomFormsBackEnd (backend)

trigger: none  # Manual only

resources:
  pipelines:
    - pipeline: buildPipeline
      source: 'Custom Forms - Build'
      trigger: true

variables:
  # Deployment paths
  runtimeDeployPath: 'E:\BIZUITSites\arielsch\arielschBIZUITCustomForms'
  backendDeployPath: 'E:\BIZUITSites\arielsch\arielschBIZUITCustomFormsBackEnd'
  backendDotNetDeployPath: 'E:\BIZUITSites\arielsch\arielschBIZUITCustomFormsBackEndDotNet'

  # PM2 app names
  pm2RuntimeApp: 'arielsch-runtime'
  pm2BackendApp: 'arielsch-backend'

  # IIS site names for .NET backend
  iisSiteName: 'test.bizuit.com'
  iisAppPoolName: 'arielschBIZUITCustomFormsBackEndDotNet'

  # Runtime configuration
  runtimeBasePath: '/arielschBIZUITCustomForms'
  runtimePort: '3001'
  backendPort: '8000'
  backendDotNetPort: '8001'

  # Standalone Forms (Iframe) Configuration
  allowedIframeOrigins: 'https://test.bizuit.com,https://*.bizuit.com'
  allowLocalhostIframe: 'false'

stages:
  # ==========================================================================
  # STAGE 3: Run Database Migrations
  # ==========================================================================
  - stage: RunMigrations
    displayName: 'Run Database Migrations'
    condition: succeeded()
    pool:
      name: Testbizuitcom  # Self-hosted agent
    jobs:
      - job: MigrationsJob
        displayName: 'Execute SQL Migrations'
        steps:
          - task: DownloadBuildArtifacts@0
            inputs:
              buildType: 'specific'
              project: '$(System.TeamProject)'
              pipeline: 'Custom Forms - Build'
              buildVersionToDownload: 'latest'
              downloadType: 'single'
              artifactName: 'migrations-drop'
              downloadPath: '$(System.ArtifactsDirectory)'
            displayName: 'Download Migration Scripts (fast download)'

          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "=== Running Database Migrations ===" -ForegroundColor Cyan

                $migrationsPath = "$(System.ArtifactsDirectory)\migrations-drop\migrations"

                if (-not (Test-Path $migrationsPath)) {
                    Write-Host "‚ö†Ô∏è  No migrations directory found" -ForegroundColor Yellow
                    Write-Host "Skipping migrations..."
                    exit 0
                }

                # Get all SQL files in migrations directory
                $sqlFiles = Get-ChildItem -Path $migrationsPath -Filter "*.sql" | Sort-Object Name

                if ($sqlFiles.Count -eq 0) {
                    Write-Host "‚ö†Ô∏è  No SQL migration files found" -ForegroundColor Yellow
                    exit 0
                }

                Write-Host "Found $($sqlFiles.Count) migration file(s)" -ForegroundColor Green

                # Read or create .env.local
                $envPath = "$(backendDeployPath)\.env.local"

                # Create backend deploy directory if it doesn't exist
                $backendDir = "$(backendDeployPath)"
                if (-not (Test-Path $backendDir)) {
                    New-Item -ItemType Directory -Path $backendDir -Force | Out-Null
                    Write-Host "‚úì Created backend directory: $backendDir" -ForegroundColor Green
                }

                # Check if .env.local exists, create only if missing
                if (-not (Test-Path $envPath)) {
                    Write-Host "‚ö†Ô∏è  .env.local not found, creating with default configuration..." -ForegroundColor Yellow

                    # Create .env.local with production configuration (use array to avoid YAML heredoc issues)
                    $envLines = @(
                      "# SQL Server Connection - Dashboard Database",
                      "DB_SERVER=test.bizuit.com",
                      "DB_DATABASE=arielschBIZUITDashboard",
                      "DB_USER=BIZUITarielsch",
                      "DB_PASSWORD=Th3Qu33n1sD34d$",
                      "",
                      "# SQL Server Connection - Persistence Store Database",
                      "PERSISTENCE_DB_SERVER=test.bizuit.com",
                      "PERSISTENCE_DB_DATABASE=arielschBizuitPersistenceStore",
                      "PERSISTENCE_DB_USER=BIZUITarielsch",
                      "PERSISTENCE_DB_PASSWORD=Th3Qu33n1sD34d$",
                      "",
                      "# Bizuit Dashboard API (backend connects to BPM)",
                      "BIZUIT_DASHBOARD_API_URL=https://test.bizuit.com/arielschbizuitdashboardapi/api",
                      "",
                      "# Security Configuration",
                      "ADMIN_ALLOWED_ROLES=Administrators,BIZUIT Admins,SuperAdmin,FormManager",
                      "SESSION_TIMEOUT_MINUTES=30",
                      "JWT_SECRET_KEY=prod-$(New-Guid)-$((Get-Date).ToString('yyyyMMddHHmmss'))",
                      "ENCRYPTION_TOKEN_KEY=Vq2ixrmV6oUGhQfIPWiCBk0S",
                      "",
                      "# API Configuration",
                      "API_PORT=8000",
                      "MAX_UPLOAD_SIZE_MB=50",
                      "TEMP_UPLOAD_PATH=./temp-uploads",
                      "",
                      "# CORS Configuration (production - no localhost for security)",
                      "CORS_ORIGINS=https://test.bizuit.com",
                      "",
                      "# Python Environment",
                      "PYTHONUNBUFFERED=1",
                      "ENVIRONMENT=production"
                    )

                    $envLines | Out-File -FilePath $envPath -Encoding utf8

                    Write-Host "‚úì Created $envPath" -ForegroundColor Green
                    Write-Host ""
                } else {
                    Write-Host "‚úì .env.local already exists, preserving existing configuration" -ForegroundColor Green
                }

                Write-Host "Reading database configuration from .env.local..." -ForegroundColor Gray

                # Parse .env.local
                $envVars = @{}
                Get-Content $envPath | ForEach-Object {
                    if ($_ -match '^([^#][^=]+)=(.+)$') {
                        $envVars[$matches[1].Trim()] = $matches[2].Trim()
                    }
                }

                # Use DB_* variables (for CustomForms tables in Dashboard DB)
                $dbServer = $envVars['DB_SERVER']
                $dbDatabase = $envVars['DB_DATABASE']
                $dbUser = $envVars['DB_USER']
                $dbPassword = $envVars['DB_PASSWORD']

                # Validate database configuration
                if ($dbDatabase -ne "arielschBIZUITDashboard") {
                    Write-Host "`n========================================" -ForegroundColor Red
                    Write-Host "‚ö†Ô∏è  WARNING: Incorrect Database Configuration" -ForegroundColor Red
                    Write-Host "========================================" -ForegroundColor Red
                    Write-Host "Current database: $dbDatabase" -ForegroundColor Yellow
                    Write-Host "Expected database: arielschBIZUITDashboard" -ForegroundColor Yellow
                    Write-Host "`nPlease update $envPath manually:" -ForegroundColor Yellow
                    Write-Host "  DB_DATABASE=arielschBIZUITDashboard" -ForegroundColor Gray
                    Write-Host "  PERSISTENCE_DB_DATABASE=arielschBIZUITDashboard" -ForegroundColor Gray
                    Write-Host "========================================`n" -ForegroundColor Red
                    throw "Database configuration is incorrect. Please fix .env.local and re-run deployment."
                }

                if (-not $dbServer -or -not $dbDatabase) {
                    Write-Error "‚ùå Missing database configuration in .env.local"
                    Write-Error "Required: PERSISTENCE_DB_SERVER, PERSISTENCE_DB_DATABASE (or DB_SERVER, DB_DATABASE)"
                    exit 1
                }

                Write-Host "Target Database: $dbServer\$dbDatabase" -ForegroundColor Gray

                # Test SQL Server connection first
                Write-Host "`nTesting SQL Server connection..." -ForegroundColor Yellow
                try {
                    $testCmd = "sqlcmd"
                    $testArgs = @(
                        "-S", $dbServer,
                        "-d", $dbDatabase,
                        "-U", $dbUser,
                        "-P", $dbPassword,
                        "-Q", "SELECT DB_NAME() AS CurrentDatabase, @@VERSION AS SQLVersion",
                        "-b"
                    )

                    Write-Host "Command: sqlcmd -S $dbServer -d $dbDatabase -U $dbUser -P ****** -Q 'SELECT DB_NAME()...'" -ForegroundColor Gray
                    $testOutput = & $testCmd $testArgs 2>&1

                    if ($LASTEXITCODE -eq 0) {
                        Write-Host "‚úì SQL Server connection successful" -ForegroundColor Green
                        Write-Host $testOutput -ForegroundColor Gray
                    } else {
                        Write-Error "‚ùå Cannot connect to SQL Server"
                        Write-Host "Error output:" -ForegroundColor Red
                        Write-Host $testOutput -ForegroundColor Red
                        Write-Host "`nTroubleshooting:" -ForegroundColor Yellow
                        Write-Host "1. Verify SQL Server is accessible from this agent" -ForegroundColor Gray
                        Write-Host "2. Check credentials in .env.local" -ForegroundColor Gray
                        Write-Host "3. Ensure sqlcmd is installed on the agent" -ForegroundColor Gray
                        exit 1
                    }
                } catch {
                    Write-Error "‚ùå Error testing connection: $_"
                    exit 1
                }

                # Execute each migration file
                foreach ($file in $sqlFiles) {
                    Write-Host "`n--- Executing: $($file.Name) ---" -ForegroundColor Yellow

                    try {
                        # Use sqlcmd to execute the migration
                        $sqlcmd = "sqlcmd"
                        $arguments = @(
                            "-S", $dbServer,
                            "-d", $dbDatabase,
                            "-U", $dbUser,
                            "-P", $dbPassword,
                            "-i", $file.FullName,
                            "-b"  # Exit with error code on SQL errors
                        )

                        Write-Host "Executing: sqlcmd -S $dbServer -d $dbDatabase -U $dbUser -i $($file.Name)" -ForegroundColor Gray
                        $output = & $sqlcmd $arguments 2>&1
                        $exitCode = $LASTEXITCODE

                        if ($exitCode -eq 0) {
                            Write-Host "‚úì Migration executed successfully" -ForegroundColor Green
                            if ($output) {
                                Write-Host $output -ForegroundColor Gray
                            }
                        } else {
                            Write-Host "`n========================================" -ForegroundColor Red
                            Write-Host "‚ùå MIGRATION FAILED" -ForegroundColor Red
                            Write-Host "========================================" -ForegroundColor Red
                            Write-Host "Exit Code: $exitCode" -ForegroundColor Yellow
                            Write-Host "Migration File: $($file.FullName)" -ForegroundColor Yellow
                            Write-Host "`nSQL Error Output:" -ForegroundColor Red
                            Write-Host "----------------------------------------" -ForegroundColor Red
                            Write-Host $output -ForegroundColor White
                            Write-Host "----------------------------------------" -ForegroundColor Red
                            Write-Host "`nCommand executed:" -ForegroundColor Yellow
                            Write-Host "sqlcmd -S $dbServer -d $dbDatabase -U $dbUser -P ****** -i `"$($file.FullName)`"" -ForegroundColor Gray
                            throw "Migration failed with exit code $exitCode"
                        }
                    } catch {
                        Write-Host "`n‚ùå Exception during migration execution: $($_.Exception.Message)" -ForegroundColor Red
                        throw
                    }
                }

                Write-Host "`n=== All Migrations Completed Successfully ===" -ForegroundColor Green
            displayName: 'Execute Idempotent SQL Migrations'

  # ==========================================================================
  # STAGE 4: Deploy Runtime App
  # ==========================================================================
  - stage: DeployRuntime
    displayName: 'Deploy Runtime App'
    dependsOn: RunMigrations
    condition: succeeded()
    pool:
      name: Testbizuitcom
    jobs:
      - deployment: DeployRuntimeJob
        displayName: 'Deploy Next.js to PM2'
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                # Step 0: Checkout source code to get ecosystem.config.js
                - checkout: self
                  clean: true
                  displayName: 'Checkout Repository'

                # Step 1: Check/Install PM2 FIRST (fast, fails early)
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Checking PM2 installation..." -ForegroundColor Cyan

                      # Set HOMEPATH and HOME BEFORE any PM2 command (required on Windows)
                      if (-not $env:HOMEPATH) {
                          $env:HOMEPATH = $env:USERPROFILE
                          Write-Host "Set HOMEPATH to: $env:HOMEPATH" -ForegroundColor Gray
                      }
                      if (-not $env:HOME) {
                          $env:HOME = $env:USERPROFILE
                          Write-Host "Set HOME to: $env:HOME" -ForegroundColor Gray
                      }

                      # Get npm global bin path
                      $npmBin = npm config get prefix
                      $pm2CmdPath = Join-Path $npmBin "pm2.cmd"

                      # Check if PM2 exists in npm global directory (more reliable than Get-Command)
                      if (Test-Path $pm2CmdPath) {
                          Write-Host "‚úì PM2 is already installed" -ForegroundColor Green
                          $version = & $pm2CmdPath --version 2>&1
                          Write-Host "Version: $version" -ForegroundColor Gray
                      } else {
                          Write-Host "‚ö†Ô∏è  PM2 not found at $pm2CmdPath" -ForegroundColor Yellow
                          Write-Host "Installing PM2 globally..." -ForegroundColor Yellow
                          npm install -g pm2

                          # Verify installation
                          if (Test-Path $pm2CmdPath) {
                              $version = & $pm2CmdPath --version 2>&1
                              Write-Host "‚úì PM2 installed successfully" -ForegroundColor Green
                              Write-Host "Version: $version" -ForegroundColor Gray
                          } else {
                              throw "Failed to install PM2 - file not found at $pm2CmdPath"
                          }
                      }

                      # Ensure npm bin is in PATH for subsequent tasks
                      if ($env:Path -notlike "*$npmBin*") {
                          $env:Path = "$npmBin;$env:Path"
                          Write-Host "Added npm global bin to PATH: $npmBin" -ForegroundColor Gray
                      }
                  displayName: 'Ensure PM2 is Installed'

                # Step 2: Stop PM2 process BEFORE downloading (fast, fails early)
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      # Set HOMEPATH for PM2 (required on Windows)
                      if (-not $env:HOMEPATH) { $env:HOMEPATH = $env:USERPROFILE }
                      if (-not $env:HOME) { $env:HOME = $env:USERPROFILE }

                      # Add npm global bin to PATH
                      $npmBin = npm config get prefix
                      $env:Path = "$npmBin;$env:Path"

                      Write-Host "Stopping PM2 process: $(pm2RuntimeApp)"

                      # Stop process (ignore all errors - process may not exist on first deployment)
                      try {
                          pm2 stop $(pm2RuntimeApp) 2>&1 | Out-Null
                          Write-Host "‚úì Process stopped successfully"
                      } catch {
                          Write-Host "Process was not running (this is expected on first deployment)"
                      }

                      # Always exit with success
                      exit 0
                  displayName: 'Stop PM2 Runtime Process'

                # Step 3: Download artifacts AFTER PM2 is ready
                - task: DownloadBuildArtifacts@0
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProject)'
                    pipeline: 'Custom Forms - Build'
                    buildVersionToDownload: 'latest'
                    downloadType: 'single'
                    artifactName: 'runtime-drop'
                    downloadPath: '$(System.ArtifactsDirectory)'
                  displayName: 'Download Runtime Artifacts'

                # Copy PM2 ecosystem.config.js to server
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(Build.SourcesDirectory)/custom-forms'
                    Contents: 'ecosystem.config.js'
                    TargetFolder: 'E:\BIZUITSites\arielsch'
                    OverWrite: true
                  displayName: 'Copy PM2 Ecosystem Config'

                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Preparing deployment directory..."

                      # Clean deployment directory (preserve .env.local and logs)
                      if (Test-Path "$(runtimeDeployPath)") {
                          Write-Host "Cleaning deployment directory..."
                          Get-ChildItem "$(runtimeDeployPath)" -Exclude @('.env.local', 'logs') | Remove-Item -Recurse -Force
                      } else {
                          Write-Host "Creating deployment directory..."
                          New-Item -ItemType Directory -Path "$(runtimeDeployPath)" -Force | Out-Null
                      }

                      # Ensure logs directory exists
                      New-Item -ItemType Directory -Path "$(runtimeDeployPath)\logs" -Force -ErrorAction SilentlyContinue | Out-Null

                      Write-Host "‚úì Deployment directory prepared"
                  displayName: 'Prepare Deployment Directory'

                # Copy standalone build (contains server.js, .next, node_modules, package.json)
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(System.ArtifactsDirectory)/runtime-drop/runtime-app/.next/standalone'
                    Contents: '**'
                    TargetFolder: '$(runtimeDeployPath)'
                    OverWrite: true
                  displayName: 'Copy Standalone Server Files'

                # Copy static assets (not included in standalone)
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(System.ArtifactsDirectory)/runtime-drop/runtime-app/.next/static'
                    Contents: '**'
                    TargetFolder: '$(runtimeDeployPath)/.next/static'
                    OverWrite: true
                  displayName: 'Copy Static Assets'

                # Copy prepare-deployment scripts
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(System.ArtifactsDirectory)/runtime-drop/runtime-app/scripts'
                    Contents: |
                      prepare-deployment.js
                      prepare-deployment.ps1
                    TargetFolder: '$(runtimeDeployPath)/scripts'
                    OverWrite: true
                  displayName: 'Copy Deployment Scripts'

                # Copy web.config for IIS
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(System.ArtifactsDirectory)/runtime-drop/runtime-app'
                    Contents: 'web.config.production'
                    TargetFolder: '$(runtimeDeployPath)'
                    OverWrite: true
                  displayName: 'Copy Web Config'

                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    workingDirectory: '$(runtimeDeployPath)'
                    script: |
                      Write-Host "=== Applying Runtime basePath Configuration ===" -ForegroundColor Cyan

                      # Execute prepare-deployment script to replace placeholder with actual basePath
                      $env:RUNTIME_BASEPATH = "$(runtimeBasePath)"
                      Write-Host "Setting RUNTIME_BASEPATH to: $env:RUNTIME_BASEPATH" -ForegroundColor Yellow

                      # Check if Node.js script exists (PREFERRED - more reliable)
                      if (Test-Path "scripts\prepare-deployment.js") {
                          Write-Host "Executing Node.js prepare-deployment script..." -ForegroundColor Gray
                          node scripts\prepare-deployment.js

                          if ($LASTEXITCODE -ne 0) {
                              Write-Error "‚ùå Failed to execute prepare-deployment.js"
                              exit 1
                          }
                          Write-Host "‚úì basePath replacement completed successfully" -ForegroundColor Green

                          # Verify replacements were made
                          Write-Host "Verifying basePath replacements..." -ForegroundColor Gray
                          $serverJs = Get-Content "server.js" -Raw
                          if ($serverJs -match "__RUNTIME_BASEPATH__") {
                              Write-Error "‚ùå Placeholder still found in server.js after replacement!"
                              Write-Host "This indicates the prepare-deployment script failed silently."
                              exit 1
                          }
                          Write-Host "‚úì No placeholders found - replacement successful" -ForegroundColor Green

                      } elseif (Test-Path "scripts\prepare-deployment.ps1") {
                          Write-Host "‚ö†Ô∏è  Using PowerShell script (Node.js script preferred)" -ForegroundColor Yellow
                          Write-Host "Executing PowerShell prepare-deployment script..." -ForegroundColor Gray
                          & .\scripts\prepare-deployment.ps1 -RuntimeBasePath "$(runtimeBasePath)"

                          if ($LASTEXITCODE -ne 0) {
                              Write-Error "‚ùå Failed to execute prepare-deployment.ps1"
                              exit 1
                          }
                          Write-Host "‚úì basePath replacement completed successfully" -ForegroundColor Green
                      } else {
                          Write-Error "‚ùå No prepare-deployment script found in scripts directory"
                          Write-Host "Expected: scripts\prepare-deployment.js or scripts\prepare-deployment.ps1"
                          exit 1
                      }

                      Write-Host ""
                  displayName: 'Apply Runtime basePath Configuration'

                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    workingDirectory: '$(runtimeDeployPath)'
                    script: |
                      Write-Host "Configuring runtime app for production..."

                      # Copy production web.config
                      if (Test-Path "web.config.production") {
                          Copy-Item "web.config.production" "web.config" -Force
                          Write-Host "‚úì web.config.production copied as web.config"

                          # Replace placeholders in web.config
                          Write-Host "Configuring web.config with runtime values..." -ForegroundColor Gray
                          $content = Get-Content "web.config" -Raw
                          # Remove leading slash from basePath for replacement (template already has /)
                          $basePathNoSlash = '$(runtimeBasePath)' -replace '^/', ''
                          $content = $content -replace '__RUNTIME_PORT__', '$(runtimePort)'
                          $content = $content -replace '__BACKEND_PORT__', '$(backendPort)'
                          $content = $content -replace '__RUNTIME_BASEPATH__', $basePathNoSlash
                          Set-Content -Path "web.config" -Value $content -NoNewline
                          Write-Host "‚úì web.config configured: runtime=$(runtimePort), backend=$(backendPort), basePath=$(runtimeBasePath)"

                          # Validate web.config is valid XML
                          try {
                              [xml]$webConfig = Get-Content "web.config"
                              Write-Host "‚úì web.config is valid XML"
                          } catch {
                              Write-Error "‚ùå web.config is not valid XML: $($_.Exception.Message)"
                              Write-Host "`nweb.config content:"
                              Get-Content "web.config" | Select-Object -First 20
                              exit 1
                          }

                          # Remove web.config.production from deployment directory
                          Remove-Item "web.config.production" -Force
                          Write-Host "‚úì web.config.production removed (no longer needed)"
                      } else {
                          Write-Warning "‚ö†Ô∏è  web.config.production not found"
                      }

                      # Create or verify .env.local for runtime
                      $envPath = ".env.local"
                      if (-not (Test-Path $envPath)) {
                          Write-Host "Creating .env.local for runtime with production configuration..." -ForegroundColor Yellow

                          $envLines = @(
                              "# Production Environment Variables for Runtime App",
                              "# Auto-generated by Azure DevOps deployment pipeline",
                              "",
                              "# Base path for IIS deployment",
                              "NEXT_PUBLIC_BASE_PATH=/arielschBIZUITCustomForms",
                              "",
                              "# Bizuit BPM Dashboard API URL (browser connects to Bizuit BPM)",
                              "# MUST be absolute URL for browser requests",
                              "NEXT_PUBLIC_BIZUIT_DASHBOARD_API_URL=https://test.bizuit.com/arielschbizuitdashboardapi/api",
                              "",
                              "# Custom Forms Backend API URL (.NET Core backend)",
                              "# MUST be absolute URL for browser requests",
                              "NEXT_PUBLIC_BIZUIT_FORMS_API_URL=https://test.bizuit.com/arielschBIZUITCustomFormsBackendDotNet",
                              "",
                              "# Backend API URL (REQUIRED - server-side only, used by Next.js API routes)",
                              "# Points to IIS-hosted .NET backend",
                              "FASTAPI_URL=https://test.bizuit.com/arielschBIZUITCustomFormsBackendDotNet",
                              "",
                              "# Timeouts and configuration",
                              "NEXT_PUBLIC_BIZUIT_TIMEOUT=30000",
                              "NEXT_PUBLIC_BIZUIT_TOKEN_EXPIRATION_MINUTES=1440",
                              "",
                              "# Session timeout for admin panel",
                              "NEXT_PUBLIC_SESSION_TIMEOUT_MINUTES=30",
                              "",
                              "# Webhook secret (not used in production - form uploads happen via pipeline)",
                              "WEBHOOK_SECRET=not-used-in-production",
                              "",
                              "# üîí CRITICAL SECURITY: Form Access Control",
                              "# Server-side only - can be changed per deployment without rebuild",
                              "# Set to 'true' for testing environments, 'false' for production",
                              "# If undefined or false, direct access to forms is BLOCKED (secure by default)",
                              "NEXT_PUBLIC_ALLOW_DEV_MODE=true",
                              "",
                              "# üîí Standalone Forms (Iframe) Configuration",
                              "# Allowed origins for iframe embedding (/formsa/* routes)",
                              "# Comma-separated list of domains, supports wildcards: https://*.bizuit.com",
                              "NEXT_PUBLIC_ALLOWED_IFRAME_ORIGINS=$(allowedIframeOrigins)",
                              "",
                              "# Allow localhost for iframe testing (ONLY for development, false in production)",
                              "NEXT_PUBLIC_ALLOW_LOCALHOST_IFRAME=$(allowLocalhostIframe)",
                              "",
                              "# Environment",
                              "NODE_ENV=production",
                              "DEPLOY_ENV=production"
                          )

                          $envLines | Out-File -FilePath $envPath -Encoding utf8
                          Write-Host "‚úì Created $envPath" -ForegroundColor Green
                      } else {
                          Write-Host "‚úì .env.local already exists, preserving existing configuration" -ForegroundColor Green
                      }

                      # Install production dependencies
                      Write-Host "Installing production dependencies..."
                      npm install --omit=dev

                      Write-Host "‚úì Runtime app configured"
                  displayName: 'Configure Runtime App'

                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      # Set HOMEPATH for PM2 (required on Windows)
                      if (-not $env:HOMEPATH) { $env:HOMEPATH = $env:USERPROFILE }
                      if (-not $env:HOME) { $env:HOME = $env:USERPROFILE }

                      # Add npm global bin to PATH
                      $npmBin = npm config get prefix
                      $env:Path = "$npmBin;$env:Path"

                      Write-Host "Starting PM2 process: $(pm2RuntimeApp)"

                      # Try to restart (if exists) or start (if new)
                      try {
                          pm2 restart $(pm2RuntimeApp) 2>&1 | Out-Null
                          if ($LASTEXITCODE -eq 0) {
                              Write-Host "‚úì Process restarted successfully"
                          } else {
                              throw "Restart failed, will start new instance"
                          }
                      } catch {
                          Write-Host "Process not found, starting new instance..."
                          pm2 start E:\BIZUITSites\arielsch\ecosystem.config.js --only $(pm2RuntimeApp)
                      }

                      # Save PM2 configuration
                      pm2 save --force

                      Write-Host "‚úì PM2 process started"
                  displayName: 'Start PM2 Runtime Process'

                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      # Set HOMEPATH for PM2 (required on Windows)
                      if (-not $env:HOMEPATH) { $env:HOMEPATH = $env:USERPROFILE }
                      if (-not $env:HOME) { $env:HOME = $env:USERPROFILE }

                      # Add npm global bin to PATH for pm2 logs command
                      $npmBin = npm config get prefix
                      $env:Path = "$npmBin;$env:Path"

                      Write-Host "Health check: Testing runtime app..."

                      $maxAttempts = 10
                      $success = $false

                      for ($i = 1; $i -le $maxAttempts; $i++) {
                          Write-Host "Attempt $i of $maxAttempts..."
                          Start-Sleep -Seconds 5

                          try {
                              # IMPORTANT: Check with basePath included (Next.js requires full path)
                              $response = Invoke-WebRequest -Uri "http://localhost:3001$(runtimeBasePath)" -UseBasicParsing -TimeoutSec 10
                              if ($response.StatusCode -eq 200) {
                                  Write-Host "‚úÖ Runtime app is healthy!" -ForegroundColor Green
                                  $success = $true
                                  break
                              }
                          } catch {
                              Write-Host "Not ready: $($_.Exception.Message)" -ForegroundColor DarkGray
                          }
                      }

                      if (-not $success) {
                          Write-Host "`n=== PM2 Logs ===" -ForegroundColor Red
                          pm2 logs $(pm2RuntimeApp) --lines 50 --nostream
                          Write-Error "‚ùå Runtime app failed health check"
                          exit 1
                      }
                  displayName: 'Runtime Health Check'

  # ==========================================================================
  # STAGE 5: Deploy Backend API (.NET Core)
  # ==========================================================================
  - stage: DeployBackend
    displayName: 'Deploy Backend API (.NET)'
    dependsOn: RunMigrations
    condition: succeeded()
    pool:
      name: Testbizuitcom
    jobs:
      - deployment: DeployBackendJob
        displayName: 'Deploy .NET Core Backend to IIS'
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                # Step 1: Download .NET backend artifacts
                - task: DownloadBuildArtifacts@0
                  inputs:
                    buildType: 'specific'
                    project: '$(System.TeamProject)'
                    pipeline: 'Custom Forms - Build'
                    buildVersionToDownload: 'latest'
                    downloadType: 'single'
                    artifactName: 'backend-dotnet-drop'
                    downloadPath: '$(System.ArtifactsDirectory)'
                  displayName: 'Download .NET Backend Artifacts'

                # Step 2: Stop IIS App Pool
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Stopping IIS App Pool: $(iisAppPoolName)" -ForegroundColor Cyan

                      # Import IIS module
                      Import-Module WebAdministration

                      # Check if app pool exists
                      $appPool = Get-Item "IIS:\AppPools\$(iisAppPoolName)" -ErrorAction SilentlyContinue

                      if ($appPool) {
                          # Stop app pool if running
                          if ($appPool.State -eq 'Started') {
                              Stop-WebAppPool -Name "$(iisAppPoolName)"
                              Write-Host "‚úì App pool stopped" -ForegroundColor Green

                              # Wait for app pool to fully stop
                              $maxWait = 30
                              $waited = 0
                              while ((Get-WebAppPoolState -Name "$(iisAppPoolName)").Value -ne 'Stopped' -and $waited -lt $maxWait) {
                                  Start-Sleep -Seconds 1
                                  $waited++
                              }

                              if ($waited -ge $maxWait) {
                                  Write-Warning "‚ö†Ô∏è  App pool did not stop within $maxWait seconds"
                              } else {
                                  Write-Host "‚úì App pool fully stopped" -ForegroundColor Green
                              }
                          } else {
                              Write-Host "‚úì App pool already stopped" -ForegroundColor Gray
                          }
                      } else {
                          Write-Host "‚ÑπÔ∏è  App pool does not exist yet (first deployment)" -ForegroundColor Gray
                      }
                  displayName: 'Stop IIS App Pool'

                # Step 3: Prepare deployment directory
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Preparing .NET backend deployment directory..." -ForegroundColor Cyan

                      $deployPath = "$(backendDotNetDeployPath)"

                      # Clean deployment directory (preserve appsettings.Production.json and logs)
                      if (Test-Path $deployPath) {
                          Write-Host "Cleaning deployment directory: $deployPath" -ForegroundColor Gray
                          Get-ChildItem $deployPath -Exclude @('appsettings.Production.json', 'logs', 'temp-uploads') | Remove-Item -Recurse -Force
                          Write-Host "‚úì Directory cleaned" -ForegroundColor Green
                      } else {
                          Write-Host "Creating deployment directory: $deployPath" -ForegroundColor Gray
                          New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
                          Write-Host "‚úì Directory created" -ForegroundColor Green
                      }

                      # Ensure required directories exist
                      New-Item -ItemType Directory -Path "$deployPath\logs" -Force -ErrorAction SilentlyContinue | Out-Null
                      New-Item -ItemType Directory -Path "$deployPath\temp-uploads" -Force -ErrorAction SilentlyContinue | Out-Null

                      Write-Host "‚úì Deployment directory prepared" -ForegroundColor Green
                  displayName: 'Prepare Deployment Directory'

                # Step 4: Copy .NET backend files
                - task: CopyFiles@2
                  inputs:
                    SourceFolder: '$(System.ArtifactsDirectory)/backend-dotnet-drop'
                    Contents: '**'
                    TargetFolder: '$(backendDotNetDeployPath)'
                    OverWrite: true
                  displayName: 'Copy .NET Backend Files'

                # Step 5: Configure appsettings.Production.json (if not exists)
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    workingDirectory: '$(backendDotNetDeployPath)'
                    script: |
                      Write-Host "Configuring .NET backend for production..." -ForegroundColor Cyan

                      $appSettingsPath = "appsettings.Production.json"

                      if (-not (Test-Path $appSettingsPath)) {
                          Write-Host "‚ö†Ô∏è  appsettings.Production.json not found, creating default..." -ForegroundColor Yellow

                          $appSettings = @{
                              "Logging" = @{
                                  "LogLevel" = @{
                                      "Default" = "Information"
                                      "Microsoft.AspNetCore" = "Warning"
                                  }
                              }
                              "AllowedHosts" = "*"
                              "ConnectionStrings" = @{
                                  "DashboardDb" = "Server=test.bizuit.com;Database=arielschBIZUITDashboard;User Id=BIZUITarielsch;Password=Th3Qu33n1sD34d`$;TrustServerCertificate=True;Encrypt=True"
                                  "PersistenceDb" = "Server=test.bizuit.com;Database=arielschBizuitPersistenceStore;User Id=BIZUITarielsch;Password=Th3Qu33n1sD34d`$;TrustServerCertificate=True;Encrypt=True"
                              }
                              "BizuitSettings" = @{
                                  "DashboardApiUrl" = "https://test.bizuit.com/arielschbizuitdashboardapi/api"
                                  "AdminAllowedRoles" = "Administrators,BIZUIT Admins,SuperAdmin,FormManager"
                                  "SessionTimeoutMinutes" = 30
                                  "JwtSecretKey" = "CHANGE_THIS_IN_PRODUCTION_" + (New-Guid).ToString() + "_" + (Get-Date).ToString('yyyyMMddHHmmss')
                                  "EncryptionTokenKey" = "Vq2ixrmV6oUGhQfIPWiCBk0S"
                                  "MaxUploadSizeMB" = 50
                                  "TempUploadPath" = "./temp-uploads"
                              }
                              "CorsSettings" = @{
                                  "AllowedOrigins" = @("https://test.bizuit.com")
                              }
                          } | ConvertTo-Json -Depth 10

                          $appSettings | Out-File -FilePath $appSettingsPath -Encoding UTF8
                          Write-Host "‚úì Created appsettings.Production.json" -ForegroundColor Green
                          Write-Host "‚ö†Ô∏è  IMPORTANT: Review and update production secrets!" -ForegroundColor Yellow
                      } else {
                          Write-Host "‚úì appsettings.Production.json already exists" -ForegroundColor Green
                      }

                      Write-Host "‚úì .NET backend configured" -ForegroundColor Green
                  displayName: 'Configure .NET Backend'

                # Step 6: Create/Update IIS App Pool and Application
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Configuring IIS App Pool and Application..." -ForegroundColor Cyan

                      Import-Module WebAdministration

                      $appPoolName = "$(iisAppPoolName)"
                      $siteName = "$(iisSiteName)"
                      $appName = "arielschBIZUITCustomFormsBackendDotNet"
                      $deployPath = "$(backendDotNetDeployPath)"

                      # Create App Pool if it doesn't exist
                      if (-not (Test-Path "IIS:\AppPools\$appPoolName")) {
                          Write-Host "Creating App Pool: $appPoolName" -ForegroundColor Gray
                          New-WebAppPool -Name $appPoolName
                          Write-Host "‚úì App Pool created" -ForegroundColor Green
                      } else {
                          Write-Host "‚úì App Pool already exists: $appPoolName" -ForegroundColor Gray
                      }

                      # Configure App Pool for .NET Core
                      Write-Host "Configuring App Pool settings..." -ForegroundColor Gray
                      Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "managedRuntimeVersion" -Value ""
                      Set-ItemProperty -Path "IIS:\AppPools\$appPoolName" -Name "enable32BitAppOnWin64" -Value $false
                      Write-Host "‚úì App Pool configured for .NET Core" -ForegroundColor Green

                      # Verify site exists first
                      $siteExists = Test-Path "IIS:\Sites\$siteName"
                      if (-not $siteExists) {
                          Write-Error "‚ùå IIS Site '$siteName' does not exist"
                          Write-Host "Available sites:" -ForegroundColor Yellow
                          Get-ChildItem "IIS:\Sites" | ForEach-Object { Write-Host "  - $($_.Name)" }
                          exit 1
                      }

                      # Create IIS Application if it doesn't exist
                      $appPath = "IIS:\Sites\$siteName\$appName"
                      if (-not (Test-Path $appPath)) {
                          Write-Host "Creating IIS Application: $appName under site $siteName" -ForegroundColor Gray

                          try {
                              # Try to create as Application first
                              New-WebApplication -Name $appName -Site $siteName -PhysicalPath $deployPath -ApplicationPool $appPoolName -ErrorAction Stop
                              Write-Host "‚úì IIS Application created" -ForegroundColor Green
                          } catch {
                              Write-Host "‚ö†Ô∏è  Could not create as Application, trying Virtual Directory..." -ForegroundColor Yellow
                              Write-Host "Error: $($_.Exception.Message)" -ForegroundColor DarkGray

                              # Fallback: Create as Virtual Directory, then convert to Application
                              New-Item -Path "IIS:\Sites\$siteName" -Name $appName -Type VirtualDirectory -PhysicalPath $deployPath -Force
                              Write-Host "‚úì Virtual Directory created" -ForegroundColor Green

                              # Convert to Application and assign app pool
                              ConvertTo-WebApplication -ApplicationPath "/$appName" -PSPath "IIS:\Sites\$siteName"
                              Set-ItemProperty -Path $appPath -Name "applicationPool" -Value $appPoolName
                              Write-Host "‚úì Converted to Application with app pool" -ForegroundColor Green
                          }
                      } else {
                          Write-Host "‚úì IIS Application already exists" -ForegroundColor Gray
                          # Update physical path and app pool in case they changed
                          Set-ItemProperty -Path $appPath -Name "physicalPath" -Value $deployPath
                          Set-ItemProperty -Path $appPath -Name "applicationPool" -Value $appPoolName
                          Write-Host "‚úì IIS Application updated" -ForegroundColor Green
                      }

                      Write-Host "‚úì IIS configuration complete" -ForegroundColor Green
                      Write-Host "Application URL: https://$siteName/$appName" -ForegroundColor Cyan
                  displayName: 'Configure IIS App Pool and Application'

                # Step 7: Start IIS App Pool
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Starting IIS App Pool: $(iisAppPoolName)" -ForegroundColor Cyan

                      Import-Module WebAdministration

                      Start-WebAppPool -Name "$(iisAppPoolName)"

                      # Wait for app pool to start
                      $maxWait = 30
                      $waited = 0
                      while ((Get-WebAppPoolState -Name "$(iisAppPoolName)").Value -ne 'Started' -and $waited -lt $maxWait) {
                          Start-Sleep -Seconds 1
                          $waited++
                      }

                      if ($waited -ge $maxWait) {
                          Write-Error "‚ùå App pool did not start within $maxWait seconds"
                          exit 1
                      }

                      Write-Host "‚úì App pool started successfully" -ForegroundColor Green
                  displayName: 'Start IIS App Pool'

                # Step 8: Health Check
                - task: PowerShell@2
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Health check: Testing .NET backend API..." -ForegroundColor Cyan

                      $maxAttempts = 15
                      $success = $false
                      $siteName = "$(iisSiteName)"
                      $appName = "arielschBIZUITCustomFormsBackendDotNet"

                      for ($i = 1; $i -le $maxAttempts; $i++) {
                          Write-Host "Attempt $i of $maxAttempts..." -ForegroundColor Gray
                          Start-Sleep -Seconds 5

                          try {
                              # Try health endpoint
                              $response = Invoke-WebRequest -Uri "https://$siteName/$appName/" -UseBasicParsing -TimeoutSec 10
                              if ($response.StatusCode -eq 200) {
                                  Write-Host "‚úÖ .NET Backend API is healthy!" -ForegroundColor Green
                                  Write-Host "Response: $($response.Content)" -ForegroundColor Gray
                                  $success = $true
                                  break
                              }
                          } catch {
                              Write-Host "Not ready: $($_.Exception.Message)" -ForegroundColor DarkGray
                          }
                      }

                      if (-not $success) {
                          Write-Host "`n=== IIS Application Event Log ===" -ForegroundColor Red
                          Get-EventLog -LogName Application -Source "IIS*" -Newest 20 | Format-Table -AutoSize
                          Write-Error "‚ùå .NET backend failed health check"
                          exit 1
                      }

                      Write-Host "`n‚úÖ Deployment Complete!" -ForegroundColor Green
                      Write-Host "Backend API URL: https://$siteName/$appName" -ForegroundColor Cyan
                  displayName: '.NET Backend Health Check'
