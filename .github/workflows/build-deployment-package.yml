name: Build Deployment Package (Offline)

on:
  push:
    branches:
      - main
      - release/*
    paths:
      - '*/src/**'           # Cambios en source de cualquier form
      - '*/package.json'     # Cambios en package.json de forms
      - 'build-form.js'      # Cambios en script de build compartido
  workflow_dispatch:
    inputs:
      version:
        description: 'Package version (e.g., 1.0.0)'
        required: true
        default: '1.0.0'
      release_notes:
        description: 'Release notes (optional, will use commit message if empty)'
        required: false
        type: string

jobs:
  build-deployment-package:
    name: Build Offline Deployment Package
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Necesario para hacer push al repositorio

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Para obtener commit hash

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Get version info
        id: version
        run: |
          # Usar input manual o generar autom√°ticamente
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            # Autoincremento sem√°ntico basado en tags git
            echo "üîç Detecting version from git tags..."

            # Obtener √∫ltimo tag (formato vX.Y.Z)
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
            echo "Last tag: $LAST_TAG"

            # Extraer versi√≥n sin 'v' prefix
            LAST_VERSION=${LAST_TAG#v}

            # Separar major.minor.patch
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LAST_VERSION"

            # Detectar tipo de cambio basado en mensaje del commit
            COMMIT_MSG=$(git log -1 --pretty=%B)

            if echo "$COMMIT_MSG" | grep -qiE "^(BREAKING CHANGE|major):"; then
              # Major version bump (breaking changes)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              BUMP_TYPE="major"
            elif echo "$COMMIT_MSG" | grep -qiE "^(feat|feature|minor):"; then
              # Minor version bump (new features)
              MINOR=$((MINOR + 1))
              PATCH=0
              BUMP_TYPE="minor"
            else
              # Patch version bump (bug fixes, chore, docs, etc.)
              PATCH=$((PATCH + 1))
              BUMP_TYPE="patch"
            fi

            VERSION="$MAJOR.$MINOR.$PATCH"
            echo "üîº Auto-increment ($BUMP_TYPE): $LAST_VERSION ‚Üí $VERSION"
          fi

          COMMIT_HASH="${{ github.sha }}"
          SHORT_HASH="${COMMIT_HASH:0:7}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT

          echo "üì¶ Package Version: $VERSION"
          echo "üîñ Commit: $SHORT_HASH"
          echo "üìÖ Build Date: $BUILD_DATE"

      - name: Detect changed forms
        id: changed_forms
        run: |
          echo "üîç Detecting changed forms..."

          # Obtener lista de forms modificados desde el √∫ltimo commit
          # Buscar cambios en directorios que contengan src/ o package.json
          CHANGED_FORMS=$(git diff --name-only HEAD~1 HEAD | grep -E '^[^/]+/(src/|package\.json)' | cut -d'/' -f1 | sort -u || true)

          if [ -z "$CHANGED_FORMS" ]; then
            echo "‚ö†Ô∏è  No forms changed, building all forms"
            # Si no hay cambios, buscar todos los forms
            CHANGED_FORMS=$(find . -type f -name "package.json" -not -path "*/node_modules/*" -not -path "./package.json" | xargs dirname | xargs -n1 basename)
          fi

          # Convertir a array para GitHub Output
          FORMS_ARRAY=$(echo "$CHANGED_FORMS" | tr '\n' ' ')
          echo "changed_forms=$FORMS_ARRAY" >> $GITHUB_OUTPUT

          echo "üìù Forms to build:"
          echo "$CHANGED_FORMS"

      - name: Build changed forms
        run: |
          echo "üî® Building forms..."

          FORMS_TO_BUILD="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_BUILD; do
            if [ -d "$form_name" ] && [ -f "$form_name/package.json" ]; then
              echo "  üìù Building: $form_name"
              cd "$form_name"

              # Verificar que existe el script de build
              if npm run | grep -q "build"; then
                npm run build

                if [ -f "dist/form.js" ]; then
                  echo "  ‚úÖ Built successfully: $form_name ($(wc -c < dist/form.js) bytes)"
                else
                  echo "  ‚ùå Build failed: $form_name (no dist/form.js)"
                  exit 1
                fi
              else
                echo "  ‚ö†Ô∏è  No build script found for: $form_name"
              fi

              cd ..
            fi
          done

      - name: Extract release notes
        id: release_notes
        run: |
          echo "üìù Extracting release notes..."

          # Prioridad 1: Input manual (workflow_dispatch)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.release_notes }}" ]; then
            RELEASE_NOTES="${{ github.event.inputs.release_notes }}"
            echo "‚ÑπÔ∏è  Using manual release notes from workflow input"
          else
            # Prioridad 2: Mensaje del commit
            COMMIT_MESSAGE=$(git log -1 --pretty=format:"%B")

            # Si el mensaje del commit tiene formato especial (conventional commits), extraerlo
            # Formato esperado: "feat: descripci√≥n\n\n- cambio 1\n- cambio 2"
            if echo "$COMMIT_MESSAGE" | grep -q "^feat:\|^fix:\|^chore:\|^docs:\|^refactor:\|^perf:\|^test:"; then
              # Extraer todo despu√©s del t√≠tulo (primera l√≠nea)
              RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | tail -n +2 | sed '/^$/d')

              if [ -z "$RELEASE_NOTES" ]; then
                # Si no hay cuerpo, usar solo el t√≠tulo
                RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | head -n 1)
              fi
            else
              # Usar el mensaje del commit completo
              RELEASE_NOTES="$COMMIT_MESSAGE"
            fi

            # Si est√° vac√≠o, usar mensaje por defecto
            if [ -z "$RELEASE_NOTES" ]; then
              RELEASE_NOTES="Version ${{ steps.version.outputs.version }} - Build autom√°tico"
            fi
          fi

          # Guardar en archivo temporal
          echo "$RELEASE_NOTES" > /tmp/release_notes.txt

          echo "‚úÖ Release notes extracted:"
          echo "$RELEASE_NOTES"

      - name: Generate manifest.json
        id: manifest
        run: |
          echo "üìã Generating manifest.json..."

          # Crear manifest.json din√°micamente con info extendida
          cat > manifest.json << EOF
          {
            "packageVersion": "${{ steps.version.outputs.version }}",
            "buildDate": "${{ steps.version.outputs.build_date }}",
            "commitHash": "${{ steps.version.outputs.commit_hash }}",
            "commitShortHash": "${{ steps.version.outputs.short_hash }}",
            "gitTag": "v${{ steps.version.outputs.version }}",
            "repositoryUrl": "${{ github.server_url }}/${{ github.repository }}",
            "commitUrl": "${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.version.outputs.commit_hash }}",
            "workflowRunUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "forms": [
          EOF

          # Leer release notes del archivo temporal
          RELEASE_NOTES=$(cat /tmp/release_notes.txt)

          # Agregar SOLO los forms compilados al manifest
          FORMS_TO_MANIFEST="${{ steps.changed_forms.outputs.changed_forms }}"
          first=true

          for form_name in $FORMS_TO_MANIFEST; do
            # Verificar que exista el form compilado
            if [ -d "$form_name" ] && [ -f "$form_name/package.json" ] && [ -f "$form_name/dist/form.js" ]; then
              version=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
              description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
              author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")

              # ProcessName = FormName con capitalizaci√≥n (AprobacionGastos)
              process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')

              size=$(wc -c < "$form_name/dist/form.js")

              # Escapar release notes para JSON (convertir a JSON string)
              release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

              # Agregar coma si no es el primero
              if [ "$first" = false ]; then
                echo "," >> manifest.json
              fi
              first=false

              # Agregar form al manifest con releaseNotes
              cat >> manifest.json << FORM_EOF
              {
                "formName": "$form_name",
                "processName": "$process_name",
                "version": "$version",
                "author": "$author",
                "description": "$description",
                "sizeBytes": $size,
                "path": "forms/$form_name/form.js",
                "releaseNotes": $release_notes_json
              }
          FORM_EOF
            fi
          done

          # Cerrar manifest.json
          cat >> manifest.json << EOF
            ]
          }
          EOF

          # Pretty print
          jq '.' manifest.json > manifest.tmp && mv manifest.tmp manifest.json

          echo "‚úÖ Manifest generated:"
          cat manifest.json

          # Contar forms
          form_count=$(jq '.forms | length' manifest.json)
          echo "form_count=$form_count" >> $GITHUB_OUTPUT

      - name: Create deployment package structure
        run: |
          echo "üì¶ Creating deployment package structure..."

          mkdir -p deployment-package/forms

          # Copiar manifest.json
          cp manifest.json deployment-package/

          # Crear VERSION.txt con informaci√≥n completa
          cat > deployment-package/VERSION.txt << EOF
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          BIZUIT CUSTOM FORMS DEPLOYMENT PACKAGE
          ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

          Package Version:     ${{ steps.version.outputs.version }}
          Git Tag:             v${{ steps.version.outputs.version }}
          Build Date:          ${{ steps.version.outputs.build_date }}

          Git Commit:          ${{ steps.version.outputs.commit_hash }}
          Short Hash:          ${{ steps.version.outputs.short_hash }}

          Repository:          ${{ github.repository }}
          Branch:              ${{ github.ref_name }}
          Workflow Run:        #${{ github.run_number }}

          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          LINKS
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

          View Commit:         ${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.version.outputs.commit_hash }}
          View Tag:            ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }}
          View Workflow:       ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          FORMS IN THIS PACKAGE
          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

          EOF

          # Listar forms en VERSION.txt
          jq -r '.forms[] | "  ‚Ä¢ \(.formName) (\(.processName)) - v\(.version)"' manifest.json >> deployment-package/VERSION.txt

          echo "" >> deployment-package/VERSION.txt
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" >> deployment-package/VERSION.txt

          # Copiar SOLO los forms que fueron compilados
          FORMS_TO_PACKAGE="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_PACKAGE; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              mkdir -p "deployment-package/forms/$form_name"
              cp "$form_name/dist/form.js" "deployment-package/forms/$form_name/"
              echo "  ‚úÖ Copied: $form_name"
            fi
          done

          echo "üìÇ Package structure:"
          tree deployment-package || find deployment-package -type f

      - name: Verify deployment package structure
        run: |
          echo "üìã Package structure:"
          tree deployment-package || find deployment-package -type f

          echo ""
          echo "üìä Package stats:"
          du -sh deployment-package
          echo "Forms: ${{ steps.manifest.outputs.form_count }}"

      - name: Prepare and upload individual form artifacts
        run: |
          echo "üì§ Creating individual artifacts for each form..."

          FORMS_TO_UPLOAD="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_UPLOAD; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              echo ""
              echo "üì¶ Preparing artifact for: $form_name"

              # Crear directorio temporal para artifact de este form
              ARTIFACT_DIR="artifact-$form_name"
              mkdir -p "$ARTIFACT_DIR"

              # Copiar manifest y VERSION
              cp deployment-package/manifest.json "$ARTIFACT_DIR/"
              cp deployment-package/VERSION.txt "$ARTIFACT_DIR/"

              # Copiar solo este form
              mkdir -p "$ARTIFACT_DIR/forms/$form_name"
              cp "$form_name/dist/form.js" "$ARTIFACT_DIR/forms/$form_name/"

              echo "  ‚úÖ Artifact structure prepared for: $form_name"
              echo "  üìÅ Directory: $ARTIFACT_DIR"
            fi
          done

      # Upload artifacts individually (GitHub Actions will create separate artifacts)
      - name: Upload sample-form-2 artifact
        if: contains(steps.changed_forms.outputs.changed_forms, 'sample-form-2')
        uses: actions/upload-artifact@v4
        with:
          name: sample-form-2-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}
          path: artifact-sample-form-2/
          retention-days: 90

      - name: Upload dashboard-integration-demo artifact
        if: contains(steps.changed_forms.outputs.changed_forms, 'dashboard-integration-demo')
        uses: actions/upload-artifact@v4
        with:
          name: dashboard-integration-demo-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}
          path: artifact-dashboard-integration-demo/
          retention-days: 90

      - name: Upload aprobacion-gastos artifact
        if: contains(steps.changed_forms.outputs.changed_forms, 'aprobacion-gastos')
        uses: actions/upload-artifact@v4
        with:
          name: aprobacion-gastos-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}
          path: artifact-aprobacion-gastos/
          retention-days: 90

      - name: Upload solicitud-vacaciones artifact
        if: contains(steps.changed_forms.outputs.changed_forms, 'solicitud-vacaciones')
        uses: actions/upload-artifact@v4
        with:
          name: solicitud-vacaciones-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}
          path: artifact-solicitud-vacaciones/
          retention-days: 90

      - name: Upload solicitud-soporte artifact
        if: contains(steps.changed_forms.outputs.changed_forms, 'solicitud-soporte')
        uses: actions/upload-artifact@v4
        with:
          name: solicitud-soporte-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}
          path: artifact-solicitud-soporte/
          retention-days: 90

      - name: Create deployment ZIPs (one per form)
        run: |
          echo "üì¶ Creating individual deployment ZIPs for each form..."

          FORMS_TO_PACKAGE="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_PACKAGE; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              echo ""
              echo "üìù Creating ZIP for: $form_name"

              # Crear estructura temporal para este form
              mkdir -p "temp-package-$form_name"

              # Copiar manifest.json y VERSION.txt
              cp deployment-package/manifest.json "temp-package-$form_name/"
              cp deployment-package/VERSION.txt "temp-package-$form_name/"

              # Copiar solo este form
              mkdir -p "temp-package-$form_name/forms/$form_name"
              cp "$form_name/dist/form.js" "temp-package-$form_name/forms/$form_name/"

              # Nombre del ZIP espec√≠fico para este form
              PACKAGE_NAME="${form_name}-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}.zip"

              # Crear ZIP
              cd "temp-package-$form_name"
              zip -r "../$PACKAGE_NAME" .
              cd ..

              # Copiar a directorio upload/ del form
              mkdir -p "$form_name/upload"
              cp "$PACKAGE_NAME" "$form_name/upload/"

              # Limpiar directorio temporal
              rm -rf "temp-package-$form_name"

              echo "  ‚úÖ Created: $PACKAGE_NAME ($(wc -c < "$PACKAGE_NAME") bytes)"
              echo "  üìÅ Copied to: $form_name/upload/"
            fi
          done

          echo ""
          echo "üìä Deployment ZIPs created:"
          ls -lh *-deployment-*.zip 2>/dev/null || echo "  (check individual form upload/ directories)"

          echo ""
          echo "üîó Traceability:"
          echo "  - Each ZIP is named: {form-name}-deployment-{version}-{hash}.zip"
          echo "  - ZIP filename includes version + commit hash"
          echo "  - VERSION.txt inside ZIP has full git information"
          echo "  - manifest.json has commit URLs for direct navigation"

      - name: Commit and push deployment ZIPs to repository
        run: |
          echo "üìù Committing deployment ZIPs to repository..."

          # Configurar git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Agregar archivos ZIP y directorio upload/
          git add */upload/*.zip || true
          git add */upload/ || true

          # Verificar si hay cambios
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No deployment ZIPs to commit"
          else
            # Crear commit
            git commit -m "chore: add deployment package ZIPs [skip ci]" \
                       -m "Generated by workflow run #${{ github.run_number }}" \
                       -m "Version: ${{ steps.version.outputs.version }}" \
                       -m "Commit: ${{ steps.version.outputs.commit_hash }}" \
                       -m "ü§ñ Automated commit by GitHub Actions"

            # Push usando el token del workflow
            git push origin HEAD:main

            echo "‚úÖ Deployment ZIPs committed and pushed to repository"
          fi

      - name: Create and push version tag
        if: github.event_name != 'workflow_dispatch'
        run: |
          echo "üè∑Ô∏è  Creating version tag..."

          # Configurar git (si no est√° configurado)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          TAG_NAME="v${{ steps.version.outputs.version }}"

          # Verificar si el tag ya existe
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag $TAG_NAME already exists, skipping tag creation"
          else
            # Crear tag anotado
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME" \
                                    -m "Auto-generated by workflow run #${{ github.run_number }}" \
                                    -m "Build date: ${{ steps.version.outputs.build_date }}" \
                                    -m "Commit: ${{ steps.version.outputs.commit_hash }}"

            # Push del tag
            git push origin "$TAG_NAME"

            echo "‚úÖ Tag $TAG_NAME created and pushed"
          fi

      - name: Create release (if manual trigger)
        if: github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Custom Forms Deployment v${{ steps.version.outputs.version }}
          body: |
            ## üì¶ Deployment Package - Offline Installation

            **Version**: ${{ steps.version.outputs.version }}
            **Commit**: [`${{ steps.version.outputs.short_hash }}`](${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.version.outputs.commit_hash }})
            **Build Date**: ${{ steps.version.outputs.build_date }}
            **Forms included**: ${{ steps.manifest.outputs.form_count }}

            ### üîó Traceability

            This package is directly linked to git:
            - **Package filename**: Contains version + commit hash for easy identification
            - **VERSION.txt**: Full git information inside the ZIP
            - **manifest.json**: Direct URLs to commit, tag, and workflow run

            ### üì• Installation Instructions

            Each form has its own deployment ZIP:
            - Download `{form-name}-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}.zip`
            - Transfer to offline server (USB, network share, etc.)
            - Access: `https://your-server.com/BIZUITCustomForms/admin/upload-forms`
            - Upload the ZIP file directly (no need to extract first)
            - Verify deployment success

            ### üìã Forms in this package

            Check `manifest.json` or `VERSION.txt` inside each ZIP for complete information.

            ---

            ü§ñ Generated automatically by GitHub Actions - [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          files: |
            *-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "## üéâ Deployment Package Built Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ steps.version.outputs.commit_hash }}" >> $GITHUB_STEP_SUMMARY
          echo "**Forms**: ${{ steps.manifest.outputs.form_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì• Download" >> $GITHUB_STEP_SUMMARY
          echo "Go to **Actions** ‚Üí **Artifacts** to download the deployment package" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì§ Upload Instructions" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the ZIP from artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. Transfer to offline server" >> $GITHUB_STEP_SUMMARY
          echo "3. Upload via: \`/admin/upload-forms\`" >> $GITHUB_STEP_SUMMARY
