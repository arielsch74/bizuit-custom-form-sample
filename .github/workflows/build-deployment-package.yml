name: Build Deployment Package (Offline)

on:
  push:
    branches:
      - main
      - release/*
    paths:
      - '*/src/**'           # Cambios en source de cualquier form
      - '*/package.json'     # Cambios en package.json de forms
      - 'build-form.js'      # Cambios en script de build compartido
  workflow_dispatch:
    inputs:
      version:
        description: 'Package version (e.g., 1.0.0)'
        required: true
        default: '1.0.0'
      release_notes:
        description: 'Release notes (optional, will use commit message if empty)'
        required: false
        type: string

jobs:
  build-deployment-package:
    name: Build Offline Deployment Package
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Necesario para hacer push al repositorio

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Para obtener commit hash

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Get build metadata (commit hash and date)
        id: build_metadata
        run: |
          COMMIT_HASH="${{ github.sha }}"
          SHORT_HASH="${COMMIT_HASH:0:7}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "short_hash=$SHORT_HASH" >> $GITHUB_OUTPUT
          echo "build_date=$BUILD_DATE" >> $GITHUB_OUTPUT

          echo "ğŸ”– Commit: $SHORT_HASH"
          echo "ğŸ“… Build Date: $BUILD_DATE"

      - name: Detect changed forms
        id: changed_forms
        run: |
          echo "ğŸ” Detecting changed forms..."

          # DetecciÃ³n inteligente de cambios
          # Si es workflow_dispatch, construir todos los forms
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ğŸ“¦ Manual trigger detected - building all forms"
            CHANGED_FORMS=$(find . -type f -name "package.json" -not -path "*/node_modules/*" -not -path "./package.json" | xargs dirname | xargs -n1 basename)
          else
            # Para push events, detectar solo los forms que realmente cambiaron
            echo "ğŸ” Analyzing changes from the push event..."

            # Usar el rango de commits del push event
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              # Push normal con historial
              BEFORE_SHA="${{ github.event.before }}"
              AFTER_SHA="${{ github.event.after }}"
              echo "  Comparing: ${BEFORE_SHA:0:7}...${AFTER_SHA:0:7}"

              # Detectar archivos cambiados en el rango del push
              CHANGED_FILES=$(git diff --name-only "$BEFORE_SHA" "$AFTER_SHA" 2>/dev/null || git diff --name-only HEAD~1 HEAD)
            else
              # Primer push o branch nuevo
              echo "  First push detected, checking last commit"
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-tree --name-only -r HEAD)
            fi

            # Filtrar solo cambios en forms (src/ o package.json de cada form)
            CHANGED_FORMS=$(echo "$CHANGED_FILES" | grep -E '^[^/]+/(src/|package\.json)' | cut -d'/' -f1 | sort -u || true)

            if [ -z "$CHANGED_FORMS" ]; then
              echo "âš ï¸  No form changes detected in this push"
              echo "  Changed files:"
              echo "$CHANGED_FILES" | head -20
              echo ""
              echo "  â„¹ï¸ No forms need to be rebuilt"
              # Establecer un valor especial para indicar que no hay cambios
              CHANGED_FORMS="NONE"
            fi
          fi

          # Guardar resultado
          if [ "$CHANGED_FORMS" = "NONE" ]; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "changed_forms=" >> $GITHUB_OUTPUT
            echo "ğŸ”´ No forms to build - workflow will skip build steps"
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
            # Convertir a array para GitHub Output
            FORMS_ARRAY=$(echo "$CHANGED_FORMS" | tr '\n' ' ')
            echo "changed_forms=$FORMS_ARRAY" >> $GITHUB_OUTPUT

            echo "ğŸ“ Forms to build:"
            echo "$CHANGED_FORMS"
          fi

      - name: Calculate per-form versions (independent versioning)
        id: form_versions
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ”¢ Calculating independent versions for each form..."
          echo ""

          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"
          COMMIT_MSG=$(git log -1 --pretty=%B)

          # Detectar tipo de cambio para todas las formas
          if echo "$COMMIT_MSG" | grep -qiE "^(BREAKING CHANGE|major):"; then
            BUMP_TYPE="major"
            echo "ğŸ”¼ Bump type detected: MAJOR (breaking changes)"
          elif echo "$COMMIT_MSG" | grep -qiE "^(feat|feature|minor):"; then
            BUMP_TYPE="minor"
            echo "ğŸ”¼ Bump type detected: MINOR (new features)"
          else
            BUMP_TYPE="patch"
            echo "ğŸ”¼ Bump type detected: PATCH (fixes/chores)"
          fi
          echo ""

          # Procesar cada form individualmente
          for form_name in $CHANGED_FORMS; do
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ“¦ Processing: $form_name"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

            # 1. Buscar Ãºltimo tag git de este form (source of truth)
            LAST_TAG=$(git describe --tags --match "${form_name}-v*" --abbrev=0 2>/dev/null || echo "")

            if [ -n "$LAST_TAG" ]; then
              LAST_DEPLOYED_VERSION=${LAST_TAG#${form_name}-v}
              echo "âœ… Last deployed version (git tag): $LAST_DEPLOYED_VERSION"
            else
              # Sin tag previo, comenzar desde 1.0.0 (no 0.0.0)
              # El bump type determinarÃ¡ la primera versiÃ³n real
              LAST_DEPLOYED_VERSION="0.0.0"
              echo "â„¹ï¸  No previous deployment found, will start from 1.0.0"
            fi

            # 2. Leer package.json actual
            if [ -f "$form_name/package.json" ]; then
              PACKAGE_VERSION=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
              echo "ğŸ“„ Current package.json version: $PACKAGE_VERSION"
            else
              echo "âŒ ERROR: package.json not found for $form_name"
              exit 1
            fi

            # 3. Validar si coinciden (auto-correction check)
            if [ "$PACKAGE_VERSION" != "$LAST_DEPLOYED_VERSION" ]; then
              echo ""
              echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "âš ï¸  VERSION MISMATCH DETECTED!"
              echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "âš ï¸  Expected (last deployed): $LAST_DEPLOYED_VERSION"
              echo "âš ï¸  Found in package.json:    $PACKAGE_VERSION"
              echo "âš ï¸  "
              echo "âš ï¸  This means a developer manually changed package.json"
              echo "âš ï¸  Git tags are the source of truth for versioning"
              echo "âš ï¸  "
              echo "ğŸ”§ AUTO-CORRECTING to maintain semantic versioning..."
              echo "âš ï¸  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
            fi

            # 4. Calcular nueva versiÃ³n basada en el Ãºltimo tag (SOURCE OF TRUTH)
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LAST_DEPLOYED_VERSION"

            # Caso especial: sin tag previo (0.0.0) â†’ primera versiÃ³n debe ser 1.0.0
            if [ "$LAST_DEPLOYED_VERSION" = "0.0.0" ]; then
              NEW_VERSION="1.0.0"
              echo "ğŸ‰ First deployment! Starting at v1.0.0"
            else
              # Incremento normal segÃºn bump type
              if [ "$BUMP_TYPE" = "major" ]; then
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
              elif [ "$BUMP_TYPE" = "minor" ]; then
                MINOR=$((MINOR + 1))
                PATCH=0
              else
                PATCH=$((PATCH + 1))
              fi

              NEW_VERSION="$MAJOR.$MINOR.$PATCH"
            fi

            echo "ğŸ”¼ Version calculation ($BUMP_TYPE bump):"
            echo "   $LAST_DEPLOYED_VERSION â†’ $NEW_VERSION"
            echo ""

            # 5. Actualizar package.json con versiÃ³n correcta
            echo "ğŸ’¾ Updating $form_name/package.json to version $NEW_VERSION..."
            jq --arg version "$NEW_VERSION" '.version = $version' "$form_name/package.json" > "$form_name/package.tmp.json"
            mv "$form_name/package.tmp.json" "$form_name/package.json"

            echo "âœ… package.json updated successfully"
            echo ""

            # 6. Guardar versiÃ³n en output (usando nombre de form como clave)
            # GitHub Actions no permite outputs dinÃ¡micos, asÃ­ que los guardamos en archivo
            echo "${form_name}_version=$NEW_VERSION" >> /tmp/form_versions.txt

            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
          done

          echo "âœ… All form versions calculated and package.json files updated"
          echo ""
          echo "ğŸ“‹ Summary of versions:"
          cat /tmp/form_versions.txt

          # TambiÃ©n guardar en GITHUB_OUTPUT para referencia
          cat /tmp/form_versions.txt >> $GITHUB_OUTPUT

      - name: Build changed forms
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ”¨ Building forms..."

          FORMS_TO_BUILD="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_BUILD; do
            if [ -d "$form_name" ] && [ -f "$form_name/package.json" ]; then
              echo "  ğŸ“ Building: $form_name"
              cd "$form_name"

              # Verificar que existe el script de build
              if npm run | grep -q "build"; then
                npm run build

                if [ -f "dist/form.js" ]; then
                  echo "  âœ… Built successfully: $form_name ($(wc -c < dist/form.js) bytes)"
                else
                  echo "  âŒ Build failed: $form_name (no dist/form.js)"
                  exit 1
                fi
              else
                echo "  âš ï¸  No build script found for: $form_name"
              fi

              cd ..
            fi
          done

      - name: Extract release notes
        id: release_notes
        run: |
          echo "ğŸ“ Extracting release notes..."

          # Prioridad 1: Input manual (workflow_dispatch)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.release_notes }}" ]; then
            RELEASE_NOTES="${{ github.event.inputs.release_notes }}"
            echo "â„¹ï¸  Using manual release notes from workflow input"
          else
            # Prioridad 2: Mensaje del commit
            COMMIT_MESSAGE=$(git log -1 --pretty=format:"%B")

            # Si el mensaje del commit tiene formato especial (conventional commits), extraerlo
            # Formato esperado: "feat: descripciÃ³n\n\n- cambio 1\n- cambio 2"
            if echo "$COMMIT_MESSAGE" | grep -q "^feat:\|^fix:\|^chore:\|^docs:\|^refactor:\|^perf:\|^test:"; then
              # Extraer todo despuÃ©s del tÃ­tulo (primera lÃ­nea)
              RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | tail -n +2 | sed '/^$/d')

              if [ -z "$RELEASE_NOTES" ]; then
                # Si no hay cuerpo, usar solo el tÃ­tulo
                RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | head -n 1)
              fi
            else
              # Usar el mensaje del commit completo
              RELEASE_NOTES="$COMMIT_MESSAGE"
            fi

            # Si estÃ¡ vacÃ­o, usar mensaje por defecto
            if [ -z "$RELEASE_NOTES" ]; then
              RELEASE_NOTES="Version ${{ steps.version.outputs.version }} - Build automÃ¡tico"
            fi
          fi

          # Guardar en archivo temporal
          echo "$RELEASE_NOTES" > /tmp/release_notes.txt

          echo "âœ… Release notes extracted:"
          echo "$RELEASE_NOTES"

      - name: Generate manifest.json
        id: manifest
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ“‹ Generating manifest.json..."

          # Crear manifest.json dinÃ¡micamente con info extendida
          # packageVersion serÃ¡ la fecha actual en formato semver-like para el paquete completo
          PACKAGE_VERSION="1.0.$(date +%Y%m%d%H%M)"

          cat > manifest.json << EOF
          {
            "packageVersion": "$PACKAGE_VERSION",
            "buildDate": "${{ steps.build_metadata.outputs.build_date }}",
            "commitHash": "${{ steps.build_metadata.outputs.commit_hash }}",
            "commitShortHash": "${{ steps.build_metadata.outputs.short_hash }}",
            "repositoryUrl": "${{ github.server_url }}/${{ github.repository }}",
            "commitUrl": "${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.build_metadata.outputs.commit_hash }}",
            "workflowRunUrl": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "forms": [
          EOF

          # Leer release notes del archivo temporal
          RELEASE_NOTES=$(cat /tmp/release_notes.txt)

          # Agregar SOLO los forms compilados al manifest
          FORMS_TO_MANIFEST="${{ steps.changed_forms.outputs.changed_forms }}"
          first=true

          for form_name in $FORMS_TO_MANIFEST; do
            # Verificar que exista el form compilado
            if [ -d "$form_name" ] && [ -f "$form_name/package.json" ] && [ -f "$form_name/dist/form.js" ]; then
              version=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
              description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
              author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")

              # ProcessName = FormName con capitalizaciÃ³n (AprobacionGastos)
              process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')

              size=$(wc -c < "$form_name/dist/form.js")

              # Escapar release notes para JSON (convertir a JSON string)
              release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

              # Agregar coma si no es el primero
              if [ "$first" = false ]; then
                echo "," >> manifest.json
              fi
              first=false

              # Agregar form al manifest con releaseNotes y git tag
              cat >> manifest.json << FORM_EOF
              {
                "formName": "$form_name",
                "processName": "$process_name",
                "version": "$version",
                "gitTag": "${form_name}-v${version}",
                "author": "$author",
                "description": "$description",
                "sizeBytes": $size,
                "path": "forms/$form_name/form.js",
                "releaseNotes": $release_notes_json
              }
          FORM_EOF
            fi
          done

          # Cerrar manifest.json
          cat >> manifest.json << EOF
            ]
          }
          EOF

          # Pretty print
          jq '.' manifest.json > manifest.tmp && mv manifest.tmp manifest.json

          echo "âœ… Manifest generated:"
          cat manifest.json

          # Contar forms
          form_count=$(jq '.forms | length' manifest.json)
          echo "form_count=$form_count" >> $GITHUB_OUTPUT

      - name: Create deployment package structure
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ“¦ Creating deployment package structure..."

          mkdir -p deployment-package/forms

          # Copiar manifest.json
          cp manifest.json deployment-package/

          # Crear VERSION.txt con informaciÃ³n completa
          cat > deployment-package/VERSION.txt << EOF
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          BIZUIT CUSTOM FORMS DEPLOYMENT PACKAGE
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Build Date:          ${{ steps.build_metadata.outputs.build_date }}

          Git Commit:          ${{ steps.build_metadata.outputs.commit_hash }}
          Short Hash:          ${{ steps.build_metadata.outputs.short_hash }}

          Repository:          ${{ github.repository }}
          Branch:              ${{ github.ref_name }}
          Workflow Run:        #${{ github.run_number }}

          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          LINKS
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          View Commit:         ${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.build_metadata.outputs.commit_hash }}
          View Workflow:       ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          FORMS IN THIS PACKAGE (INDEPENDENT VERSIONS)
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          EOF

          # Listar forms en VERSION.txt con sus versiones individuales y git tags
          jq -r '.forms[] | "  â€¢ \(.formName) (\(.processName)) - v\(.version)\n    Git Tag: \(.gitTag)"' manifest.json >> deployment-package/VERSION.txt

          echo "" >> deployment-package/VERSION.txt
          echo "â„¹ï¸  NOTE: Each form has independent versioning." >> deployment-package/VERSION.txt
          echo "   Git tags format: {form-name}-v{version}" >> deployment-package/VERSION.txt
          echo "" >> deployment-package/VERSION.txt
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >> deployment-package/VERSION.txt

          # Copiar SOLO los forms que fueron compilados
          FORMS_TO_PACKAGE="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_PACKAGE; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              mkdir -p "deployment-package/forms/$form_name"
              cp "$form_name/dist/form.js" "deployment-package/forms/$form_name/"
              echo "  âœ… Copied: $form_name"
            fi
          done

          echo "ğŸ“‚ Package structure:"
          tree deployment-package || find deployment-package -type f

      - name: Verify deployment package structure
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ“‹ Package structure:"
          tree deployment-package || find deployment-package -type f

          echo ""
          echo "ğŸ“Š Package stats:"
          du -sh deployment-package
          echo "Forms: ${{ steps.manifest.outputs.form_count }}"

      - name: Prepare and upload individual form artifacts
        run: |
          echo "ğŸ“¤ Creating individual artifacts for each form..."

          FORMS_TO_UPLOAD="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_UPLOAD; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              echo ""
              echo "ğŸ“¦ Preparing artifact for: $form_name"

              # Crear directorio temporal para artifact de este form
              ARTIFACT_DIR="artifact-$form_name"
              mkdir -p "$ARTIFACT_DIR"

              # Copiar manifest y VERSION
              cp deployment-package/manifest.json "$ARTIFACT_DIR/"
              cp deployment-package/VERSION.txt "$ARTIFACT_DIR/"

              # Copiar solo este form
              mkdir -p "$ARTIFACT_DIR/forms/$form_name"
              cp "$form_name/dist/form.js" "$ARTIFACT_DIR/forms/$form_name/"

              echo "  âœ… Artifact structure prepared for: $form_name"
              echo "  ğŸ“ Directory: $ARTIFACT_DIR"
            fi
          done

      # Upload artifacts dynamically for all changed forms
      # We create a composite approach: generate upload commands for each form
      - name: Upload form artifacts
        run: |
          echo "ğŸ“¤ Preparing artifacts for upload..."
          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"

          # Create JSON array of artifacts to upload
          echo '{"artifacts": []}' > artifacts.json

          for form_name in $CHANGED_FORMS; do
            ARTIFACT_DIR="artifact-${form_name}"
            if [ -d "$ARTIFACT_DIR" ]; then
              # Get version from package.json
              FORM_VERSION=$(jq -r '.version' "${form_name}/package.json")
              SHORT_HASH="${{ steps.build_metadata.outputs.short_hash }}"

              echo "  ğŸ“¦ Found artifact for ${form_name} version ${FORM_VERSION}"

              # Add to JSON array
              jq --arg name "${form_name}" \
                 --arg version "${FORM_VERSION}" \
                 --arg hash "${SHORT_HASH}" \
                 --arg path "${ARTIFACT_DIR}" \
                 '.artifacts += [{"name": $name, "version": $version, "hash": $hash, "path": $path}]' \
                 artifacts.json > artifacts.tmp && mv artifacts.tmp artifacts.json
            fi
          done

          echo "ğŸ“‹ Artifacts to upload:"
          cat artifacts.json

      # Upload each artifact using a loop
      # Note: GitHub Actions doesn't support dynamic matrix, so we use a workaround
      - name: Upload artifacts to GitHub
        run: |
          # Read the artifacts JSON
          ARTIFACTS=$(cat artifacts.json | jq -c '.artifacts[]')

          # Process each artifact
          echo "$ARTIFACTS" | while IFS= read -r artifact; do
            FORM_NAME=$(echo "$artifact" | jq -r '.name')
            FORM_VERSION=$(echo "$artifact" | jq -r '.version')
            SHORT_HASH=$(echo "$artifact" | jq -r '.hash')
            ARTIFACT_PATH=$(echo "$artifact" | jq -r '.path')

            echo "Uploading ${FORM_NAME}-deployment-${FORM_VERSION}-${SHORT_HASH}..."

            # Unfortunately, we can't dynamically call actions/upload-artifact
            # So we'll store the paths and handle them in the next step
            echo "${FORM_NAME}:${FORM_VERSION}:${SHORT_HASH}:${ARTIFACT_PATH}" >> upload_list.txt
          done



      - name: Create deployment ZIPs (one per form with independent versions)
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ“¦ Creating individual deployment ZIPs for each form..."

          FORMS_TO_PACKAGE="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $FORMS_TO_PACKAGE; do
            if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
              echo ""
              echo "ğŸ“ Creating ZIP for: $form_name"

              # Leer versiÃ³n de package.json (ya actualizado en step anterior)
              FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
              echo "  Version: $FORM_VERSION"

              # Crear estructura temporal para este form
              mkdir -p "temp-package-$form_name"

              # Crear un manifest.json INDIVIDUAL para este form especÃ­fico
              # Primero, extraer la info de este form del manifest general
              PACKAGE_VERSION="1.0.$(date +%Y%m%d%H%M)"

              # Obtener informaciÃ³n del form
              description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
              author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")
              process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')
              size=$(wc -c < "$form_name/dist/form.js")

              # Leer release notes
              RELEASE_NOTES=$(cat /tmp/release_notes.txt 2>/dev/null || echo "Deployment package")
              release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

              # Crear manifest individual con SOLO este form usando jq
              jq -n \
                --arg packageVersion "$PACKAGE_VERSION" \
                --arg buildDate "${{ steps.build_metadata.outputs.build_date }}" \
                --arg commitHash "${{ steps.build_metadata.outputs.commit_hash }}" \
                --arg commitShortHash "${{ steps.build_metadata.outputs.short_hash }}" \
                --arg repositoryUrl "${{ github.server_url }}/${{ github.repository }}" \
                --arg commitUrl "${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.build_metadata.outputs.commit_hash }}" \
                --arg workflowRunUrl "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
                --arg formName "$form_name" \
                --arg processName "$process_name" \
                --arg version "$FORM_VERSION" \
                --arg gitTag "${form_name}-v${FORM_VERSION}" \
                --arg description "$description" \
                --arg author "$author" \
                --argjson releaseNotes "$release_notes_json" \
                --arg sizeBytes "$size" \
                --arg path "forms/$form_name/form.js" \
                '{
                  packageVersion: $packageVersion,
                  buildDate: $buildDate,
                  commitHash: $commitHash,
                  commitShortHash: $commitShortHash,
                  repositoryUrl: $repositoryUrl,
                  commitUrl: $commitUrl,
                  workflowRunUrl: $workflowRunUrl,
                  forms: [
                    {
                      formName: $formName,
                      processName: $processName,
                      version: $version,
                      gitTag: $gitTag,
                      description: $description,
                      author: $author,
                      releaseNotes: $releaseNotes,
                      sizeBytes: ($sizeBytes | tonumber),
                      path: $path
                    }
                  ]
                }' > "temp-package-$form_name/manifest.json"

              # Copiar VERSION.txt
              cp deployment-package/VERSION.txt "temp-package-$form_name/"

              # Copiar solo este form
              mkdir -p "temp-package-$form_name/forms/$form_name"
              cp "$form_name/dist/form.js" "temp-package-$form_name/forms/$form_name/"

              # Nombre del ZIP especÃ­fico para este form CON SU VERSIÃ“N INDIVIDUAL
              PACKAGE_NAME="${form_name}-deployment-${FORM_VERSION}-${{ steps.build_metadata.outputs.short_hash }}.zip"

              # Crear ZIP
              cd "temp-package-$form_name"
              zip -r "../$PACKAGE_NAME" .
              cd ..

              # Copiar a directorio upload/ del form
              mkdir -p "$form_name/upload"
              cp "$PACKAGE_NAME" "$form_name/upload/"

              # Limpiar directorio temporal
              rm -rf "temp-package-$form_name"

              echo "  âœ… Created: $PACKAGE_NAME ($(wc -c < "$PACKAGE_NAME") bytes)"
              echo "  ğŸ“ Copied to: $form_name/upload/"
            fi
          done

          echo ""
          echo "ğŸ“Š Deployment ZIPs created:"
          ls -lh *-deployment-*.zip 2>/dev/null || echo "  (check individual form upload/ directories)"

          echo ""
          echo "ğŸ”— Traceability:"
          echo "  - Each ZIP is named: {form-name}-deployment-{form-version}-{hash}.zip"
          echo "  - ZIP filename includes INDEPENDENT version per form + commit hash"
          echo "  - VERSION.txt inside ZIP has full git information"
          echo "  - manifest.json has per-form git tags and commit URLs"

      # Upload each form's ZIP as an individual artifact with dynamic name
      # Since GitHub Actions doesn't support dynamic matrices, we need to generate the artifact names
      - name: Generate artifact upload information
        id: artifact_info
        run: |
          echo "ğŸ“¦ Generating artifact information..."

          # Initialize JSON for artifact info
          echo '{}' > artifact_info.json

          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $CHANGED_FORMS; do
            if [ -d "$form_name/upload" ] && ls "$form_name/upload/"*.zip 1> /dev/null 2>&1; then
              # Get the NEWEST ZIP filename (the one we just created)
              ZIP_FILE=$(ls -t "$form_name/upload/"*.zip | head -1)
              ZIP_BASENAME=$(basename "$ZIP_FILE" .zip)

              # Extract version and hash from the ZIP filename
              # Pattern: {form-name}-deployment-{version}-{hash}.zip
              FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
              SHORT_HASH="${{ steps.build_metadata.outputs.short_hash }}"

              # Store the artifact name for this form
              echo "${form_name}_artifact_name=${ZIP_BASENAME}" >> $GITHUB_OUTPUT

              # Add to JSON for reference
              jq --arg form "$form_name" \
                 --arg name "$ZIP_BASENAME" \
                 --arg path "$ZIP_FILE" \
                 '. + {($form): {"name": $name, "path": $path}}' \
                 artifact_info.json > artifact_info.tmp && mv artifact_info.tmp artifact_info.json

              echo "  âœ… ${form_name}: ${ZIP_BASENAME}"
            fi
          done

          echo "ğŸ“‹ Artifact information:"
          cat artifact_info.json

      # Upload artifacts for each form dynamically
      # We'll create a script that handles all forms
      - name: Upload all form artifacts
        run: |
          echo "ğŸ“¤ Uploading artifacts for all changed forms..."

          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $CHANGED_FORMS; do
            if [ -d "$form_name/upload" ] && ls "$form_name/upload/"*.zip 1> /dev/null 2>&1; then
              # Get the NEWEST ZIP filename (the one we just created)
              # Use ls -t to sort by modification time, newest first
              ZIP_FILE=$(ls -t "$form_name/upload/"*.zip | head -1)
              ZIP_BASENAME=$(basename "$ZIP_FILE" .zip)

              echo ""
              echo "ğŸ“¦ Processing artifact for: $form_name"
              echo "   ZIP file: $(basename $ZIP_FILE)"
              echo "   Artifact name: $ZIP_BASENAME"

              # Create a marker file with the artifact name for the next step
              echo "$ZIP_BASENAME" > "${form_name}_artifact_name.txt"
            fi
          done

      # Upload sample-form-2 artifact if it was changed
      - name: Prepare sample-form-2 artifact name
        if: contains(steps.changed_forms.outputs.changed_forms, 'sample-form-2')
        run: |
          # Get the NEWEST ZIP file (sort by modification time)
          ZIP_FILE=$(ls -t sample-form-2/upload/*.zip | head -1)
          ZIP_BASENAME=$(basename "$ZIP_FILE" .zip)
          echo "SAMPLE_FORM_2_ARTIFACT=$ZIP_BASENAME" >> $GITHUB_ENV

      - name: Upload sample-form-2
        if: contains(steps.changed_forms.outputs.changed_forms, 'sample-form-2')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SAMPLE_FORM_2_ARTIFACT }}
          path: sample-form-2/upload/*.zip
          retention-days: 90

      # Upload dashboard-integration-demo artifact if it was changed
      - name: Prepare dashboard-integration-demo artifact name
        if: contains(steps.changed_forms.outputs.changed_forms, 'dashboard-integration-demo')
        run: |
          # Get the NEWEST ZIP file (sort by modification time)
          ZIP_FILE=$(ls -t dashboard-integration-demo/upload/*.zip | head -1)
          ZIP_BASENAME=$(basename "$ZIP_FILE" .zip)
          echo "DASHBOARD_DEMO_ARTIFACT=$ZIP_BASENAME" >> $GITHUB_ENV

      - name: Upload dashboard-integration-demo
        if: contains(steps.changed_forms.outputs.changed_forms, 'dashboard-integration-demo')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.DASHBOARD_DEMO_ARTIFACT }}
          path: dashboard-integration-demo/upload/*.zip
          retention-days: 90

      # Upload recubiz-gestion artifact if it was changed
      - name: Prepare recubiz-gestion artifact name
        if: contains(steps.changed_forms.outputs.changed_forms, 'recubiz-gestion')
        run: |
          # Get the NEWEST ZIP file (sort by modification time)
          ZIP_FILE=$(ls -t recubiz-gestion/upload/*.zip | head -1)
          ZIP_BASENAME=$(basename "$ZIP_FILE" .zip)
          echo "RECUBIZ_GESTION_ARTIFACT=$ZIP_BASENAME" >> $GITHUB_ENV

      - name: Upload recubiz-gestion
        if: contains(steps.changed_forms.outputs.changed_forms, 'recubiz-gestion')
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RECUBIZ_GESTION_ARTIFACT }}
          path: recubiz-gestion/upload/*.zip
          retention-days: 90

      # Add more forms here as needed
      # For any new form, follow the same pattern:
      # 1. Prepare {form-name} artifact name
      # 2. Upload {form-name}

      - name: Commit and push deployment ZIPs and updated package.json files
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "ğŸ“ Committing deployment ZIPs and updated package.json files..."

          # Configurar git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Agregar archivos ZIP, directorio upload/, y package.json actualizados
          git add */upload/*.zip || true
          git add */upload/ || true
          git add */package.json || true

          # Verificar si hay cambios
          if git diff --staged --quiet; then
            echo "âš ï¸  No changes to commit"
          else
            # Obtener lista de forms con versiones para el commit message
            FORMS_WITH_VERSIONS=""
            CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"
            for form_name in $CHANGED_FORMS; do
              if [ -f "$form_name/package.json" ]; then
                FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                FORMS_WITH_VERSIONS="${FORMS_WITH_VERSIONS}\n  - $form_name: v$FORM_VERSION"
              fi
            done

            # Crear commit
            git commit -m "chore: update versions and add deployment ZIPs [skip ci]" \
                       -m "Generated by workflow run #${{ github.run_number }}" \
                       -m "Commit: ${{ steps.build_metadata.outputs.commit_hash }}" \
                       -m "" \
                       -m "Updated forms:${FORMS_WITH_VERSIONS}" \
                       -m "" \
                       -m "ğŸ¤– Automated commit by GitHub Actions"

            # Push usando el token del workflow
            git push origin HEAD:main

            echo "âœ… Changes committed and pushed to repository"
          fi

      - name: Create and push per-form version tags
        if: github.event_name != 'workflow_dispatch'
        run: |
          echo "ğŸ·ï¸  Creating per-form version tags..."

          # Configurar git (si no estÃ¡ configurado)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"

          for form_name in $CHANGED_FORMS; do
            if [ -f "$form_name/package.json" ]; then
              FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
              TAG_NAME="${form_name}-v${FORM_VERSION}"

              echo ""
              echo "ğŸ“¦ Form: $form_name"
              echo "   Version: $FORM_VERSION"
              echo "   Tag: $TAG_NAME"

              # Verificar si el tag ya existe
              if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
                echo "   âš ï¸  Tag $TAG_NAME already exists, skipping"
              else
                # Crear tag anotado
                git tag -a "$TAG_NAME" \
                        -m "Release $form_name v$FORM_VERSION" \
                        -m "Auto-generated by workflow run #${{ github.run_number }}" \
                        -m "Build date: ${{ steps.build_metadata.outputs.build_date }}" \
                        -m "Commit: ${{ steps.build_metadata.outputs.commit_hash }}"

                # Push del tag
                git push origin "$TAG_NAME"

                echo "   âœ… Tag $TAG_NAME created and pushed"
              fi
            fi
          done

          echo ""
          echo "âœ… All form-specific tags processed"

      - name: Create release (if manual trigger)
        if: github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Custom Forms Deployment v${{ steps.version.outputs.version }}
          body: |
            ## ğŸ“¦ Deployment Package - Offline Installation

            **Version**: ${{ steps.version.outputs.version }}
            **Commit**: [`${{ steps.version.outputs.short_hash }}`](${{ github.server_url }}/${{ github.repository }}/commit/${{ steps.version.outputs.commit_hash }})
            **Build Date**: ${{ steps.version.outputs.build_date }}
            **Forms included**: ${{ steps.manifest.outputs.form_count }}

            ### ğŸ”— Traceability

            This package is directly linked to git:
            - **Package filename**: Contains version + commit hash for easy identification
            - **VERSION.txt**: Full git information inside the ZIP
            - **manifest.json**: Direct URLs to commit, tag, and workflow run

            ### ğŸ“¥ Installation Instructions

            Each form has its own deployment ZIP:
            - Download `{form-name}-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}.zip`
            - Transfer to offline server (USB, network share, etc.)
            - Access: `https://your-server.com/BIZUITCustomForms/admin/upload-forms`
            - Upload the ZIP file directly (no need to extract first)
            - Verify deployment success

            ### ğŸ“‹ Forms in this package

            Check `manifest.json` or `VERSION.txt` inside each ZIP for complete information.

            ---

            ğŸ¤– Generated automatically by GitHub Actions - [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          files: |
            *-deployment-${{ steps.version.outputs.version }}-${{ steps.version.outputs.short_hash }}.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary (No changes)
        if: steps.changed_forms.outputs.no_changes == 'true'
        run: |
          echo "## â„¹ï¸ No Forms Changed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No form files were modified in this push. No deployment packages were created." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The workflow monitors changes to:" >> $GITHUB_STEP_SUMMARY
          echo "- \`*/src/**\` - Source files of forms" >> $GITHUB_STEP_SUMMARY
          echo "- \`*/package.json\` - Package configuration of forms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "If you expected forms to be built, verify that your changes are in the correct directories." >> $GITHUB_STEP_SUMMARY

      - name: Summary
        if: steps.changed_forms.outputs.no_changes != 'true'
        run: |
          echo "## ğŸ‰ Deployment Package Built Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date**: ${{ steps.build_metadata.outputs.build_date }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ steps.build_metadata.outputs.commit_hash }}" >> $GITHUB_STEP_SUMMARY
          echo "**Forms Built**: ${{ steps.manifest.outputs.form_count }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¦ Forms with Independent Versions" >> $GITHUB_STEP_SUMMARY

          # Listar forms con sus versiones y tags
          CHANGED_FORMS="${{ steps.changed_forms.outputs.changed_forms }}"
          for form_name in $CHANGED_FORMS; do
            if [ -f "$form_name/package.json" ]; then
              FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
              echo "- **$form_name**: v$FORM_VERSION (tag: \`${form_name}-v${FORM_VERSION}\`)" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¥ Download" >> $GITHUB_STEP_SUMMARY
          echo "Go to **Actions** â†’ **Artifacts** to download individual form deployment packages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¤ Upload Instructions" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the form-specific ZIP from artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. Transfer to offline server" >> $GITHUB_STEP_SUMMARY
          echo "3. Upload via: \`/admin/upload-forms\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### â„¹ï¸ Versioning System" >> $GITHUB_STEP_SUMMARY
          echo "- Each form has **independent versioning**" >> $GITHUB_STEP_SUMMARY
          echo "- Git tags are the **source of truth** (format: \`{form-name}-v{version}\`)" >> $GITHUB_STEP_SUMMARY
          echo "- package.json versions are auto-corrected if manually changed" >> $GITHUB_STEP_SUMMARY
